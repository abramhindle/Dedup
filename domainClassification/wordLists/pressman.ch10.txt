C H A P T E R

AND PRINCIPLES

K E Y
C O N C E P T S
attributes   . . . . . 547
class hierarchy . . 551
classes. . . . . . . . . 546
CPF for OO . . . . . 560
encapsulation . . . 550
inheritance . . . . . 550
messages . . . . . . 548
OO estimation . . 564
OO metrics . . . . . 562
OO process
model . . . . . . . . . 543
objects . . . . . . . . 546
operations . . . . . 548
recursive/parallel
process . . . . . . . . 560

20 OBJECT-ORIENTED CONCEPTS
We live in a world of objects. These objects exist in nature, in human-

made entities, in business, and in the products that we use. They can
be categorized, described, organized, combined, manipulated, and
created. Therefore, it is no surprise that an object-oriented view would be pro-
posed for the creation of computer software—an abstraction that enables us to
model the world in ways that help us to better understand and navigate it. 

An object-oriented approach to the development of software was ﬁrst pro-
posed in the late 1960s. However, it took almost 20 years for object technolo-
gies to become widely used. Throughout the 1990s, object-oriented software
engineering became the paradigm of choice for many software product builders
and a growing number of information systems and engineering professionals.
As time passes, object technologies are replacing classical software develop-
ment approaches. An important question is why?

The answer (like many answers to questions about software engineering) is
not a simple one. Some people would argue that software professionals sim-
ply yearned for a “new” approach, but that view is overly simplistic. Object tech-
nologies do lead to a number of inherent benefits that provide advantage at
both the management and technical levels.

Q U I C K
L O O K

What  is  it?
There  are  many
ways to look at a problem to be
solved  using  a  software-based
solution. One widely used approach to problem
solving takes an object-oriented viewpoint. The
problem domain is characterized as a set of objects
that have specific attributes and behaviors. The
objects are manipulated with a collection of func-
tions (called methods, operations, or services) and
communicate with one another through a mes-
saging  protocol.  Objects  are  categorized  into
classes and subclasses. 

Who does it? The deﬁnition of objects encompasses
a description of attributes, behaviors, operations,
and messages. This activity is performed by a soft-
ware engineer.

Why is it important? An object encapsulates both
data and the processing that is applied to the
data. This important characteristic enables classes
of  objects  to  be  built  and  inherently  leads  to
libraries of reusable classes and objects. Because
reuse is a critically important attribute of modern
software engineering, the object-oriented para-
digm is attractive to many software development
organizations. In addition, the software compo-
nents derived using the object-oriented paradigm
exhibit design characteristics (e.g., functional inde-
pendence, information hiding) that are associated
with high-quality software.

What are the steps? Object-oriented software engi-
neering follows the same steps as conventional
approaches. Analysis identiﬁes objects and classes

541

542

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Q U I C K
L O O K

that are relevant to the problem
domain;  design  provides  the
architecture, interface, and com-
ponent-level detail; implementation (using an
object-oriented language) transforms design into
code; and testing exercises the object-oriented
architecture, interfaces and components.

What is the work product? A set of object oriented
models is produced. These models describe the

requirements, design, code, and test process for
a system or product. 

How do I ensure that I’ve done it right? At each 
stage, object-oriented work products are reviewed
for clarity, correctness, completeness, and consis-
tency with customer requirements and with one
another.

Object technologies lead to reuse, and reuse (of program components) leads to
faster software development and higher-quality programs. Object-oriented software
is easier to maintain because its structure is inherently decoupled. This leads to fewer
side effects when changes have to be made and less frustration for the software engi-
neer and the customer. In addition, object-oriented systems are easier to adapt and
easier to scale (i.e., large systems can be created by assembling reusable subsys-
tems).

In this chapter we introduce the basic principles and concepts that form a foun-
dation for the understanding of object technologies. Throughout the remainder of
Part Four of this book, we consider methods that form the basis for an engineering
approach to the creation of object-oriented products and systems. 

20.1 THE OBJECT-ORIENTED PARADIGM

For many years, the term object oriented (OO) was used to denote a software devel-
opment approach that used one of a number of object-oriented programming lan-
guages (e.g., Ada95, Java, C++, Eiffel, Smalltalk). Today, the OO paradigm encompasses
a complete view of software engineering. Edward Berard notes this when he states
[BER93]:

“With objects, it’s
actually easier to
build models [for
complex systems]
than to engage in
sequential
programming.”
David Taylor 

The benefits of object-oriented technology are enhanced if it is addressed early-on and
throughout the software engineering process. Those considering object-oriented technol-
ogy must assess its impact on the entire software engineering process. Merely employing
object-oriented programming (OOP) will not yield the best results. Software engineers and
their managers must consider such items as object-oriented requirements analysis (OORA),
object-oriented design (OOD), object-oriented domain analysis (OODA), object-oriented
database systems (OODBMS) and object-oriented computer aided software engineering
(OOCASE).

A reader who is familiar with the conventional approach to software engineering
(presented in Part Three of this book) might react to this statement with a shrug:
“What’s the big deal? We use analysis, design, programming, testing, and related tech-

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

543

FIGURE 20.1
The OO
process model

Planning

Risk

Analysis

Customer

Communication

Customer
Evaluation

Engineering,

Construction & Release

Identify
candidate
classes

Construct
nth iteration
of system

Put new
classes
in library

Look up
classes
in library

Extract
classes

if available

Engineer
classes

if unavailable

OO analysis
OO design
OO programming
OO testing

OO systems are
engineered using an
evolutionary process
model. Later in this
chapter, it will be
referred to as a
recursive parallel
model.

WebRef
One of the Web’s most
extensive lists of OO
resources can be found at
mini.net/cetus/
software.html

nologies when we engineer software using the classical methods. Why should OO
be any different?” Indeed, why should OO be any different? In short, it shouldn’t!

In Chapter 2, we discussed a number of different process models for software engi-
neering. Although any one of these models could be adapted for use with OO, the
best choice would recognize that OO systems tend to evolve over time. Therefore,
an evolutionary process model, coupled with an approach that encourages compo-
nent assembly (reuse), is the best paradigm for OO software engineering. Referring
to Figure 20.1, the component-based development process model (Chapter 2) has
been tailored for OO software engineering. 

The OO process moves through an evolutionary spiral that starts with customer
communication. It is here that the problem domain is deﬁned and that basic problem
classes (discussed later in this chapter) are identiﬁed. Planning and risk analysis estab-
lish a foundation for the OO project plan. The technical work associated with OO
software engineering follows the iterative path shown in the shaded box. OO soft-
ware engineering emphasizes reuse. Therefore, classes are “looked up” in a library
(of existing OO classes) before they are built. When a class cannot be found in the
library, the software engineer applies object-oriented analysis (OOA), object-oriented
design (OOD), object-oriented programming (OOP), and object-oriented testing (OOT)
to create the class and the objects derived from the class. The new class is then put
into the library so that it may be reused in the future.

The  object-oriented  view  demands  an  evolutionary  approach  to  software 
engineering. As we will see throughout this and the following chapters, it would be

544

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

exceedingly difﬁcult to deﬁne all necessary classes for a major system or product in
a single iteration. As the OO analysis and design models evolve, the need for addi-
tional classes becomes apparent. It is for this reason that the paradigm just described
works best for OO.

20.2 OBJECT-ORIENTED CONCEPTS

“Object-oriented
programming is not
so much a coding
technique as it is a
code packaging
technique, a way for
code suppliers to
encapsulate
functionality for
delivery to
customers.”
Brad Cox 

Any discussion of object-oriented software engineering must begin by addressing the
term object-oriented. What is an object-oriented viewpoint? Why is a method con-
sidered to be object-oriented? What is an object? Over the years, there have been
many different opinions (e.g., [BER93], [TAY90], [STR88], [BOO86]) about the correct
answers to these questions. In the discussion that follows, we attempt to synthesize
the most common of these.

To understand the object-oriented point of view, consider an example of a real
world object—the thing you are sitting in right now—a chair. Chair is a member (the
term instance is also used) of a much larger class of objects that we call furniture. A
set of generic attributes can be associated with every object in the class furniture.
For example, all furniture has a cost, dimensions, weight, location, and color, among
many possible attributes. These apply whether we are talking about a table or a chair,
a sofa or an armoire. Because chair is a member of furniture, chair inherits all attrib-
utes deﬁned for the class. This concept is illustrated schematically in Figure 20.2.

Class: furniture

Cost
Dimensions
Weight
Location
Color

The object inherits
all attributes of the class

Object: chair

Cost
Dimensions
Weight
Location
Color

FIGURE 20.2
Inheritance
from class to
object

XRef
Data modeling notation
can be used to
represent objects and
their attributes. See
Chapter 12 for details.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

545

Once the class has been deﬁned, the attributes can be reused when new instances
of the class are created. For example, assume that we were to deﬁne a new object
called a chable (a cross between a chair and a table) that is a member of the class
furniture. Chable inherits all of the attributes of furniture.

We have attempted an anecdotal deﬁnition of a class by describing its  attributes,
but something is missing. Every object in the class furniture can be manipulated in
a variety of ways. It can be bought and sold, physically modiﬁed (e.g., you can saw
off a leg or paint the object purple) or moved from one place to another. Each of these
operations (other terms are services or methods) will modify one or more attributes of
the object. For example, if the attribute location is a composite data item deﬁned as

location = building + ﬂoor + room

then an operation named move would modify one or more of the data items (building,
ﬂoor, or room) that form the attribute location. To do this, move must have "knowledge"
of these data items. The operation move could be used for a chair or a table, as long
as both are instances of the class furniture. All valid operations (e.g., buy, sell, weigh)
for the class furniture are "connected" to the object deﬁnition as shown in Figure
20.3 and are inherited by all instances of the class.

Class: furniture

Cost
Dimensions
Weight
Location
Color

Buy
Sell
Weigh
Move

Object: chable

Cost
Dimensions
Weight
Location
Color

Buy
Sell
Weigh
Move

The object inherits
all attributes and
operations of the class

Object: chair

Cost
Dimensions
Weight
Location
Color

Buy
Sell
Weigh
Move

FIGURE 20.3
Inheritance of
operations
from class to
object

546

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The object chair (and all objects in general) encapsulates data (the attribute val-
ues that deﬁne the chair), operations (the actions that are applied to change the attrib-
utes of chair), other objects (composite objects can be deﬁned [EVB89]), constants
(set values), and other related information. Encapsulation means that all of this infor-
mation is packaged under one name and can be reused as one speciﬁcation or pro-
gram component. 

Now that we have introduced a few basic concepts, a more formal deﬁnition of
object-oriented will prove more meaningful. Coad and Yourdon [COA91] deﬁne the
term this way:

object-oriented = objects + classiﬁcation + inheritance + communication

Three of these concepts have already been introduced. We postpone a discussion of
communication until later.

20.2.1 Classes and Objects
The fundamental concepts that lead to high-quality design (Chapter 13) apply equally
to systems developed using conventional and object-oriented methods. For this rea-
son, an OO model of computer software must exhibit data and procedural abstrac-
tions that lead to effective modularity. A class is an OO concept that encapsulates the
data and procedural abstractions required to describe the content and behavior of
some real world entity. Taylor {TAY90] uses the notation shown on the right side of
Figure 20.4 to describe a class (and objects derived from a class).

The data abstractions (attributes) that describe the class are enclosed by a “wall”
of procedural abstractions (called operations, methods, or services) that are capable
of manipulating the data in some way. The only way to reach the attributes (and oper-
ate on them) is to go through one of the methods that form the wall. Therefore, the
class encapsulates data (inside the wall) and the processing that manipulates the data
(the methods that make up the wall). This achieves information hiding and reduces

Class name

Attributes:

Operations:

Operations

Attributes:

“Encapsulation
prevents a program
from becoming so
interdependent that
a small change has
massive ripple
effects.”
Jim Rumbaugh 
et al.

An object encapsulates
both data (attributes)
and the functions
(operation, methods,
or services) that
manipulate the data.

FIGURE 20.4
An alternative
representation
of an object-
oriented class

One of the ﬁrst things
to think about when
building an OO system
is how to classify the
objects that are to be
manipulated by the
system.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

547

the impact of side effects associated with change. Since the methods tend to manip-
ulate a limited number of attributes, they are cohesive; and because communication
occurs only through the methods that make up the “wall,” the class tends to be decou-
pled from other elements of a system. All of these design characteristics lead to high-
quality software.

Stated another way, a class is a generalized description (e.g., a template, pattern,
or blueprint) that describes a collection of similar objects. By deﬁnition, all objects
that exist within a class inherit its attributes and the operations that are available to
manipulate the attributes. A superclass is a collection of classes, and a subclass is a
specialized instance of a class.

These deﬁnitions imply the existence of a class hierarchy in which the attributes
and operations of the superclass are inherited by subclasses that may each add addi-
tional “private” attributes and methods. A class hierarchy for the class furniture is
illustrated in Figure 20.5.

20.2.2 Attributes
We have already seen that attributes are attached to classes and objects, and that
they describe the class or object in some way. A discussion of attributes is presented
by de Champeaux, Lea, and Favre [CHA93]:

Real life entities are often described with words that indicate stable features. Most physi-
cal objects have features such as shape, weight, color, and type of material. People have
features including date of birth, parents, name, and eye color. A feature may be seen as a
binary relation between a class and a certain domain.

Furniture (superclass)

Table

Chair

Desk

“Chable”

FIGURE 20.5
A class 
hierarchy

Instances of chair

Subclasses of the
furniture superclass

548

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The values assigned to
an object’s attributes
make that object
unique.

Whenever an object is
stimulated by a
message, it initiates
some behavior by
executing an
operation.

The “binary relation” implies that an attribute can take on a value deﬁned by an enu-
merated domain. In most cases, a domain is simply a set of speciﬁc values. For exam-
ple, assume that a class automobile has an attribute color. The domain of values for
color is {white, black, silver, gray, blue, red, yellow, green}. In more complex situations, the
domain can be a set of classes. Continuing the example, the class automobile also
has an attribute power train that encompasses the following domain of classes: {16-
valve economy option, 16-valve sport option, 24-valve sport option, 32-valve luxury option}. Each
of the options noted has a set of speciﬁc attributes of its own.

The features (values of the domain) can be augmented by assigning a default value
(feature) to an attribute. For example, the power train attribute defaults to 16-valve sport
option. It may also be useful to associate a probability with a particular feature by
assigned {value, probability} pairs. Consider the color attribute for automobile. In
some applications (e.g., manufacturing planning) it might be necessary to assign a
probability to each of the colors (white and black are highly probable as automobile
colors).

20.2.3 Operations, Methods, and Services
An object encapsulates data (represented as a collection of attributes) and the algo-
rithms that process the data. These algorithms are called operations, methods, or
services1 and can be viewed as modules in a conventional sense. 

Each of the operations that is encapsulated by an object provides a representation
of one of the behaviors of the object. For example, the operation GetColor for the
object automobile will extract the color stored in the color attribute. The implication
of the existence of this operation is that the class automobile has been designed to
receive a stimulus [JAC92] (we call the stimulus a message) that requests the color of
the particular instance of a class. Whenever an object receives a stimulus, it initiates
some behavior. This can be as simple as retrieving the color of automobile or as com-
plex as the initiation of a chain of stimuli that are passed among a variety of differ-
ent objects. In the latter case, consider an example in which the initial stimulus received
by object 1 results in the generation of two other stimuli that are sent to object 2 and
object 3. Operations encapsulated by the second and third objects act on the stimuli,
returning necessary information to the ﬁrst object. Object 1 then uses the returned
information to satisfy the behavior demanded by the initial stimulus.

20.2.4 Messages
Messages are the means by which objects interact. Using the terminology introduced
in the preceding section, a message stimulates some behavior to occur in the receiv-
ing object. The behavior is accomplished when an operation is executed.

1 In the context of this discussion, we use the term operations, but methods and services are equally

popular.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

549

FIGURE 20.6
Message 
passing
between
objects

Sender object

Attributes:

Operations:

Receiver object

Attributes:

Operations:

message:

[sender, return
value(s)]

message: [receiver, operation, parameters]

“Messages and
methods
[operations] are two
sides of the same
coin. Methods are
the procedures that
are invoked when
an object receives a
message.”
Greg Voss 

The interaction between messages is illustrated schematically in Figure 20.6. An

operation within a sender object generates a message of the form

Message:   [destination, operation, parameters]

where destination deﬁnes the receiver object that is stimulated by the message, oper-
ation refers to the operation that is to receive the message, and parameters provides
information that is required for the operation to be successful. 

As an example of message passing within an OO system, consider the objects
shown in Figure 20.7. Four objects, A, B, C, and D communicate with one another
by passing messages. For example, if object B requires processing associated with
operation op10 of object D, it would send D a message of the form

message:   [D, op10, {data}]

As part of the execution of op10, object D may send a message to object C of the form

message: (C, op08, {data})

Then C ﬁnds op08, performs it, and sends an appropriate return value to D. Opera-
tion op10 completes and sends a return value to B.

Cox {COX86] describes the interchange between objects in the following manner:

An object is requested to perform one of its operations by sending it a message telling the
object what to do. The receiver [object] responds to the message by ﬁrst choosing the oper-
ation that implements the message name, executing  this operation, and then returning
control to the caller.

550

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 20.7
Message 
passing
example

A

op1
op2

B

op3
op4
op5

Message

C

op6
op7
op8
op9

Return value

D

op10
op11

Return value

Messaging ties an object-oriented system together. Messages provide insight into the
behavior of individual objects and the OO system as a whole.

20.2.5 Encapsulation, Inheritance, and Polymorphism
Although the structure and terminology introduced in Sections 20.2.1 through 20.2.4
differentiate OO systems from their conventional counterparts, three characteris-
tics of object-oriented systems make them unique. As we have already noted, the
OO class and the objects spawned from the class encapsulate data and the opera-
tions that work on the data in a single package. This provides a number of impor-
tant benefits:

• The internal implementation details of data and procedures are hidden from
the outside world (information hiding). This reduces the propagation of side
effects when changes occur. 

• Data structures and the operations that manipulate them are merged in a sin-

•

gle named entity—the class. This facilitates component reuse.
Interfaces among encapsulated objects are simpliﬁed. An object that sends a
message need not be concerned with the details of internal data structures.
Hence, interfacing is simpliﬁed and the system coupling tends to be reduced.

Inheritance is one of the key differentiators between conventional and OO sys-
tems. A subclass Y inherits all of the attributes and operations associated with its
superclass, X. This means that all data structures and algorithms originally designed

?

What are the
primary

beneﬁts of an OO
architecture?

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

551

and implemented for X are immediately available for Y—no further work need be
done. Reuse has been accomplished directly.

Any change to the data or operations contained within a superclass is immedi-
ately inherited by all subclasses that have inherited from the superclass.2 Therefore,
the class hierarchy becomes a mechanism through which changes (at high levels)
can be immediately propagated through a system.

It is important to note that, at each level of the class hierarchy, new attributes and
operations may be added to those that have been inherited from higher levels in the
hierarchy. In fact, whenever a new class is to be created, the software engineer has
a number of options:

• The class can be designed and built from scratch. That is, inheritance is not

used.

• The class hierarchy can be searched to determine if a class higher in the hier-
archy contains most of the required attributes and operations. The new class
inherits from the higher class and additions may then be added, as required.

• The class hierarchy can be restructured so that the required attributes and

operations can be inherited by the new class.

• Characteristics of an existing class can be overridden and private versions of

attributes or operations are implemented for the new class.

To illustrate how restructuring of the class hierarchy might lead to a desired class,
consider the example shown in Figures 20.8. The class hierarchy illustrated in Figure
20.8A enables us to derive classes X3 and X4 with characteristics 1, 2, 3, 4, 5 and 6
and 1, 2, 3, 4, 5, and 7, respectively.3 Now, suppose that a new class with only char-
acteristics 1, 2, 3, 4, and 8 is desired. To derive this class, called X2b in the example,
the hierarchy may be restructured as shown in Figure 20.8B. It is important to note
that restructuring the hierarchy can be difﬁcult, and for this reason, overriding is some-
times used.

In essence, overriding occurs when attributes and operations are inherited in the
normal manner but are then modiﬁed to the speciﬁc needs of the new class. As Jacob-
son notes, when overriding is used “inheritance is not transitive” [JAC92].

In some cases, it is tempting to inherit some attributes and operations from one
class and others from another class. This is called multiple inheritance, and it is con-
troversial. In general, multiple inheritance complicates the class hierarchy and cre-
ates potential problems in configuration control (Chapter 9). Because multiple
inheritance sequences are more difﬁcult to trace, changes to the deﬁnition of a class
that resides high in the hierarchy may have an unintended impact on classes deﬁned
lower in the architecture.

“Whereas an object is
a concrete entity
that exists in time
and space, a class
represents only an
abstraction, the
‘essence’ of an
object, as it were.”
Grady Booch 

2 The terms descendants and ancestors [JAC92] are sometimes used to replace subclass and super-

class, respectively.

3 For the purposes of this example, “characteristics” may be either attributes or operations.

552

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 20.8
Class 
hierarchy:
original (A),
restructured (B)

X1

char1
char2
char3

+ char4 + char5

X2

char1
char2
char3
char4
char5

+ char6

+ char7

X3

char1
char2
char3
char4
char5
char6

X4

char1
char2
char3
char4
char5
char7

(A)

X1

char1
char2
char3

X2

char1
char2
char3
char4

+ char4

+ char5

X2a

char1
char2
char3
char4
char5

+ char8

X2b

char1
char2
char3
char4
char8

+ char6

X3

char1
char2
char3
char4
char5
char6

+ char7

X4

char1
char2
char3
char4
char5
char7

(B)

“The name
[polymorphism]
may be awkward,
but the mechanism
is sheer elegance.”
David Taylor

Polymorphism is a characteristic that greatly reduces the effort required to extend
an existing OO system. To understand polymorphism, consider a conventional appli-
cation that must draw four different types of graphs: line graphs, pie charts, his-
tograms, and Kiviat diagrams. Ideally, once data are collected for a particular type of
graph, the graph should draw itself. To accomplish this in a conventional application
(and maintain module cohesion), it would be necessary to develop drawing modules
for each type of graph. Then, within the design for each graph type, control logic sim-
ilar to the following would have to be embedded:

case of graphtype:

if graphtype = linegraph then DrawLineGraph (data);
if graphtype = piechart then DrawPieChart (data);

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

553

if graphtype = histogram then DrawHisto (data);
if graphtype = kiviat then DrawKiviat (data);

end case;

Although this design is reasonably straightforward, adding new graph types could be
tricky. A new drawing module would have to be created for each graph type and then
the control logic would have to be updated for each graph.

To solve this problem, all of the graphs become subclasses of a general class called
graph. Using a concept called overloading [TAY90], each subclass deﬁnes an opera-
tion called draw. An object can send a draw message to any one of the objects instan-
tiated from any one of the subclasses. The object receiving the message will invoke
its own draw operation to create the appropriate graph. Therefore, the design is
reduced to

graphtype draw

When a new graph type is to be added to the system, a subclass is created with
its own draw operation. But no changes are required within any object that wants
a graph drawn because the message graphtype draw remains unchanged. To sum-
marize, polymorphism enables a number of different operations to have the 
same name. This in turn decouples objects from one another, making each more
independent. 

20.3 IDENTIFYING THE ELEMENTS OF AN OBJECT MODEL

The elements of an object model—classes and objects, attributes, operations, and
messages—were each deﬁned and discussed in the preceding section. But how do
we go about identifying these elements for an actual problem? The sections that fol-
low present a series of informal guidelines that will assist in the identiﬁcation of the
elements of the object model.

“The really hard
problem [in OO] is
discovering what are
the ‘right’ objects in
the ﬁrst place.”
Carl Argila 

20.3.1 Identifying Classes and Objects
If you look around a room, there is a set of physical objects that can be easily iden-
tiﬁed, classiﬁed, and deﬁned (in terms of attributes and operations). But when you
"look around" the problem space of a software application, the objects may be more
difﬁcult to comprehend.

We can begin to identify objects4 by examining the problem statement or (using
the terminology from Chapter 12) by performing a "grammatical parse" on the pro-
cessing narrative for the system to be built. Objects are determined by underlining
each noun or noun clause and entering it in a simple table. Synonyms should be

4 In reality, OOA actually attempts to deﬁne classes from which objects are instantiated. Therefore,

when we isolate potential objects, we also identify members of potential classes.

554

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 20.9
How objects
manifest 
themselves

Occurrences

Things

External entities

Roles

Organizational units

Places

Structures

Class name

Attributes:

Operations:

?

How do I 
pick out

objects as I study
the problem to be
solved?

noted. If the object is required to implement a solution, then it is part of the solution
space; otherwise, if an object is necessary only to describe a solution, it is part of the
problem space. What should we look for once all of the nouns have been isolated?
Objects manifest themselves in one of the ways represented in Figure 20.9. Objects

can be

• External entities (e.g., other systems, devices, people) that produce or con-

sume information to be used by a computer-based system.

• Things (e.g, reports, displays, letters, signals) that are part of the information

domain for the problem.

• Occurrences or events5 (e.g., a property transfer or the completion of a series

of robot movements) that occur within the context of system operation.

• Roles (e.g., manager, engineer, salesperson) played by people who interact

with the system.

• Organizational units (e.g., division, group, team) that are relevant to an appli-

cation.

• Places (e.g., manufacturing ﬂoor or loading dock) that establish the context of

the problem and the overall function of the system.

• Structures (e.g., sensors, four-wheeled vehicles, or computers) that deﬁne a

class of objects or in the extreme, related classes of objects.

5 In this context, the term event connotes any occurrence. It does not necessarily imply control as it

did in Chapter 12.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

555

This categorization is but one of many that have been proposed in the literature. For
example, Budd [BUD96] suggests a taxonomy of classes that includes producers
(sources) and consumers (sinks) of data, data managers, view or observer classes,
and helper classes.

It is also important to note what objects are not. In general, an object should never
have an "imperative procedural name" [CAS89]. For example, if the developers of
software for a medical imaging system deﬁned an object with the name image inver-
sion, they would be making a subtle mistake. The image obtained from the software
could, of course, be an object (it is a thing that is part of the information domain).
Inversion of the image is an operation that is applied to the object. It is likely that
inversion would be deﬁned as an operation for the object image, but it would not be
defined as a  separate object to connote "image inversion." As Cashman [CAS89]
states: "the intent of object-orientation is to encapsulate, but still keep separate, data
and operations on the data."

To illustrate how objects might be deﬁned during the early stages of analysis, we
return to the SafeHome security system example. In Chapter 12, we performed a "gram-
matical parse" on a processing narrative for the SafeHome system. The processing
narrative is reproduced:

SafeHome software enables the homeowner to configure the security system when it is
installed, monitors all sensors connected to the security system, and interacts with the
homeowner through a keypad and function keys contained in the SafeHome control panel
shown in Figure 11.2. 

During installation, the SafeHome control panel is used to "program" and conﬁgure the
system. Each sensor is assigned a number and type, a master password is programmed for
arming and disarming the system, and telephone number(s) are input for dialing when a
sensor event occurs.

When a sensor event is sensed by the software, it rings an audible alarm attached to the
system. After a delay time that is speciﬁed by the homeowner during system conﬁguration
activities, the software dials a telephone number of a monitoring service, provides infor-
mation about the location, reporting and the nature of the event that has been detected.
The number will be redialed every 20 seconds until telephone connection is obtained.

All interaction with SafeHome is managed by a user-interaction subsystem that reads
input provided through the keypad and function keys, displays prompting messages on the
LCD display, displays system status information on the LCD display. Keyboard interaction
takes the following form . . .

Extracting the nouns, we can propose a number of potential objects:
Potential Object/Class
homeowner
sensor
control panel
installation
system (alias security system)
number, type

General Classiﬁcation
role or external entity
external entity
external entity
occurrence
thing
not objects, attributes of sensor

A grammatical parse
can be used to isolate
potential objects
(nouns) and
operations (verbs).

556

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Potential Object/Class
master password
telephone number
sensor event
audible alarm
monitoring service

General Classiﬁcation
thing
thing
occurrence
external entity
organizational unit or external entity

?

How do I
know
whether a
potential object is
a good candidate
for use in an OO
system?

A potential object
should satisfy most or
all of these
characteristics if it is to
be used in the analysis
model.

The list would be continued until all nouns in the processing narrative have been
considered. Note that we call each entry in the list a potential object. We must con-
sider each further before a ﬁnal decision is made.

Coad and Yourdon [COA91] suggest six selection characteristics that should be
used as an analyst considers each potential object for inclusion in the analysis model:

1. Retained information. The potential object will be useful during analysis only

if information about it must be remembered so that the system can function.

2. Needed services. The potential object must have a set of identiﬁable opera-

tions that can change the value of its attributes in some way.

3. Multiple attributes. During requirement analysis, the focus should be on
"major" information; an object with a single attribute may, in fact, be useful
during design, but is probably better represented as an attribute of another
object during the analysis activity.

4. Common attributes. A set of attributes can be deﬁned for the potential

object and these attributes apply to all occurrences of the object.

5. Common operations. A set of operations can be deﬁned for the potential

object and these operations apply to all occurrences of the object.

6. Essential requirements. External entities that appear in the problem space
and produce or consume information essential to the operation of any solu-
tion for the system will almost always be deﬁned as objects in the require-
ments model.

To be considered a legitimate object for inclusion in the requirements model, a
potential object should satisfy all (or almost all) of these characteristics. The decision
for inclusion of potential objects in the analysis model is somewhat subjective, and
later evaluation may cause an object to be discarded or reinstated. However, the ﬁrst
step of OOA must be a deﬁnition of objects, and decisions (even subjective ones) must
be made. With this in mind, we apply the selection characteristics to the list of poten-
tial SafeHome objects:

Potential Object/Class
homeowner
sensor
control panel
installation
system (alias security system)

Characteristic Number That Applies
rejected: 1, 2 fail even though 6 applies
accepted: all apply
accepted: all apply
rejected
accepted: all apply

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

557

number, type
master password
telephone number
sensor event
audible alarm
monitoring service

rejected: 3 fails, attributes of sensor
rejected: 3 fails 
rejected: 3 fails
accepted: all apply
accepted: 2, 3, 4, 5, 6 apply
rejected: 1, 2 fail even though 6 applies

It should be noted that (1) the preceding list is not all-inclusive, additional objects
would have to be added to complete the model; (2) some of the rejected potential
objects will become attributes for those objects that were accepted (e.g., number and
type are attributes of sensor, and master password and telephone number may become
attributes of system); (3) different statements of the problem might cause different
"accept or reject" decisions to be made (e.g., if each homeowner had an individual
password or was identiﬁed by voice print, the homeowner object would satisfy char-
acteristics 1 and 2 and would have been accepted). 

20.3.2 Specifying Attributes
Attributes describe an object that has been selected for inclusion in the analysis model.
In essence, it is the attributes that deﬁne the object—that clarify what is meant by the
object in the context of the problem space. For example, if we were to build a system
that tracks baseball statistics for professional baseball players, the attributes of the
object player would be quite different than the attributes of the same object when it
is used in the context of the professional baseball pension system. In the former,
attributes such as name, position, batting average, ﬁelding percentage, years played, and games
played might be relevant. For the latter, some of these attributes would be meaning-
ful, but others would be replaced (or augmented) by attributes like average salary, credit
toward full vesting, pension plan options chosen, mailing address, and the like.

To develop a meaningful set of attributes for an object, the analyst can again study
the processing narrative (or statement of scope) for the problem and select those
things that reasonably "belong" to the object. In addition, the following question
should be answered for each object: "What data items (composite and/or elemen-
tary) fully deﬁne this object in the context of the problem at hand?"

To illustrate, we consider the system object deﬁned for SafeHome. We noted ear-
lier in the book that the homeowner can conﬁgure the security system to reﬂect sen-
sor information, alarm response information, activation/deactivation information,
identiﬁcation information, and so forth. Using the content description notation deﬁned
for the data dictionary and presented in Chapter 12, we can represent these com-
posite data items in the following manner:

sensor information = sensor type + sensor number + alarm threshold
alarm response information = delay time + telephone number + alarm type
activation/deactivation information = master password + number of allowable tries + tempo-

rary password

identiﬁcation information = system ID + veriﬁcation phone number + system status 

Attributes are chosen
by examining the
problem statement,
looking for things that
fully deﬁne an object
and make it unique.

558

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 20.10
The system
object with
operations
attached

Object system

System ID
Verification phone number
System status
Sensor table

Sensor type
Sensor number
Alarm threshold
Alarm delay time
Telephone number(s)
Alarm threshold
Master password
Temporary password
Number of tries

Program
Display
Reset
Query
Modify
Call

Each of the data items to the right of the equal sign could be further deﬁned to an ele-
mentary level, but for our purposes, they constitute a reasonable list of attributes for
the system object (shaded portion of Figure 20.10).

20.3.3 Deﬁning Operations
Operations deﬁne the behavior of an object and change the object’s attributes in some
way. More speciﬁcally, an operation changes one or more attribute values that are
contained within the object. Therefore, an operation must have "knowledge" of the
nature of the object's attributes and must be implemented in a manner that enables
it to manipulate the data structures that have been derived from the attributes.

Although many different types of operations exist, they can generally be divided
into three broad categories: (1) operations that manipulate data in some way (e.g.,
adding, deleting, reformatting, selecting), (2) operations that perform a computa-
tion, and (3) operations that monitor an object for the occurrence of a controlling
event.

As a first iteration at deriving a set of operations for the objects of the analysis
model, the analyst can again study the processing narrative (or statement of scope)
for the problem and select those operations that reasonably belong to the object. To
accomplish this, the grammatical parse is again studied and verbs are isolated. Some
of these verbs will be legitimate operations and can be easily connected to a speciﬁc
object. For example, from the SafeHome processing narrative presented earlier in this
chapter, we see that "sensor is assigned a number and type" or that "a master pass-

?

Is there a
reasonable

way to categorize
an object’s
operations?

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

559

word is programmed for arming and disarming the system." These two phrases indi-
cate a number of things:

• That an assign operation is relevant for the sensor object.
• That a program operation will be applied to the system object.
• That arm and disarm are operations that apply to system (also that system

status may ultimately be deﬁned (using data dictionary notation) as 

system status = [armed | disarmed]

Upon further investigation, it is likely that the operation program will be divided into
a number of more speciﬁc suboperations required to conﬁgure the system. For exam-
ple, program implies specifying phone numbers, conﬁguring system characteristics
(e.g., creating the sensor table, entering alarm characteristics), and entering pass-
word(s). But for now, we specify program as a single operation.

In addition to the grammatical parse, we can gain additional insight into other
operations by considering the communication that occurs between objects. Objects
communicate by passing messages to one another. Before continuing with the spec-
iﬁcation of operations, we explore this matter in a bit more detail.

20.3.4 Finalizing the Object Deﬁnition 
The deﬁnition of operations is the last step in completing the speciﬁcation of an object.
In Section 20.3.3, operations were culled from a grammatical parse of the process-
ing narrative for the system. Additional operations may be determined by consider-
ing the "life history" [COA91] of an object and the messages that are passed among
objects deﬁned for the system.

The generic life history of an object can be deﬁned by recognizing that the object
must be created, modiﬁed, manipulated or read in other ways, and possibly deleted.
For the system object, this can be expanded to reﬂect known activities that occur
during its life (in this case, during the time that SafeHome is operational). Some of the
operations can be ascertained from likely communication between objects. For exam-
ple, sensor event will send a message to system to display the event location and
number; control panel will send system a reset message to update system status; the
audible alarm will send a query message; the control panel will send a modify mes-
sage to change one or more attributes without reconﬁguring the entire system object;
sensor event will also send a message to call the phone number(s) contained in the
object. Other messages can be considered and operations derived. The resulting object
deﬁnition is shown in Figure 20.10.

A similar approach would be used for each of the objects deﬁned for SafeHome.
After attributes and operations are deﬁned for each of the objects identiﬁed to this
point, the beginnings of an OOA model would be created. A more detailed discus-
sion of the analysis model that is created as part of OOA is presented in Chapter 21.

560

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

20.4 MANAGEMENT OF OBJECT-ORIENTED SOFTWARE

PROJECTS

OO projects require as
much or more
management planning
and oversight as
conventional software
projects. Do not
assume that OO
somehow relieves you
of this responsibility.

As we discussed in Parts One and Two of this book, modern software project man-
agement can be subdivided into the following activities:

1. Establishing a common process framework for a project.
2. Using the framework and historical metrics to develop effort and time esti-

mates.

3. Establishing deliverables and milestones that will enable progress to be mea-

sured.

4. Deﬁning checkpoints for risk management, quality assurance, and control.
5. Managing the changes that invariably occur as the project progresses.
6. Tracking, monitoring, and controlling progress.

WebRef
An extensive OO project
management tutorial and
set of pointers can be
found at 
mini.net/cetus/
oo_project_mngt.
html

The technical manager who is faced with an object-oriented project applies these six
activities. But, because of the unique nature of object-oriented software, each of these
management activities has a subtly different feel and must be approached using a
somewhat different mind-set.

In the sections that follow, we explore software project management for object-
oriented projects. The fundamental principles of management stay the same, but the
technique must be adapted so that an OO project is properly managed.

20.4.1 The Common Process Framework for OO
A common process framework deﬁnes an organization’s approach to software engi-
neering. It identiﬁes the paradigm that is applied to build and maintain software and
the tasks, milestones, and deliverables that will be required. It establishes the degree
of rigor with which different kinds of projects will be approached. The CPF is always
adaptable so it can meet the individual needs of a project team. This is its single most
important characteristic.

As we noted earlier in this chapter, object-oriented software engineering applies
a process model that encourages iterative development. That is, OO software evolves
through a number of cycles. The common process framework that is used to man-
age an OO project must be evolutionary in nature.

Ed Berard [BER93] and Grady Booch [BOO91] among others suggest the use of a
“recursive/parallel model” for object-oriented software development. In essence the
recursive/parallel model works in the following way:

• Do enough analysis to isolate major problem classes and connections.
• Do a little design to determine whether the classes and connections can 

be implemented in a practical way.

XRef
The common process
framework deﬁnes
basic software
engineering activities.
It is described in
Chapter 2.

?

How do we
apply a

recursive/parallel
model for OO
software
engineering?

In many ways, the
architecture of an OO
system makes it easier
to initiate work in
parallel. However, be
certain that each
parallel task is deﬁned
so that progress can
be assessed.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

561

• Extract reusable objects from a library to build a rough prototype.
• Conduct some tests to uncover errors in the prototype.
• Get customer feedback on the prototype.
• Modify the analysis model based on what you’ve learned from the prototype,

from doing design, and from customer feedback.
• Reﬁne the design to accommodate your changes.
• Code special objects (that are not available from the library).
• Assemble a new prototype using objects from the library and the new objects

you’ve created.

• Conduct some tests to uncover errors in the prototype.
• Get customer feedback on the prototype.

This approach continues until the prototype evolves into a production application.

The recursive/parallel model is quite similar to the spiral or evolutionary para-
digm. Progress occurs iteratively. What makes the recursive/parallel model different
is (1) the recognition that analysis and design modeling for OO systems cannot be
accomplished at an even level of abstraction and (2) analysis and design can be
applied to independent system components concurrently. Berard [BER93] describes
the model in the following manner:

• Systematically decompose the problem into highly independent components.
• Reapply the decomposition process to each of the independent components

to decompose each further (the recursive part).

• Conduct this reapplication of decomposition concurrently on all components

(the parallel part).

• Continue this process until completion criteria are attained.

It’s important to note that this decomposition process is discontinued if the ana-
lyst/designer recognizes that the component or subcomponent required is available
in a reuse library.

To control the recursive/parallel process framework, the project manager must
recognize that progress is planned and measured incrementally. That is, project tasks
and the project schedule are tied to each of the “highly independent components,”
and progress is measured for each of these components individually.

Each iteration of the recursive/parallel process requires planning, engineering
(analysis, design, class extraction, prototyping, and testing), and evaluation activi-
ties (Figure 20.11). During planning, activities associated with each of the indepen-
dent program components are planned and scheduled. (Note: With each iteration,
the schedule is adjusted to accommodate changes associated with the preceding iter-
ation.) During early stages of engineering, analysis and design occur iteratively. The

562

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Planning

Analysis

Design

Review and refinement

Early analysis/design iterations

Analysis

Design

Analysis

Design

Review and refinement

Planning

Analysis

Design

Extract
reusable
classes

Prototype

Test

Customer
evaluation

First

prototype

Review and refinement

Planning

Analysis

Design

Extract
reusable
classes

Prototype

Test

Customer
evaluation

Next

increment

Review and refinement

Planning

Analysis

Design

Extract
reusable
classes

Prototype

Test

Customer
evaluation

nth

increment

FIGURE 20.11 Typical process sequence for an OO project

intent is to isolate all important elements of the OO analysis and design models. As
engineering work proceeds, incremental versions of the software are produced. Dur-
ing evaluation, reviews, customer evaluation, and testing are performed for each
increment, with feedback affecting the next planning activity and subsequent incre-
ment.

20.4.2 OO Project Metrics and Estimation
Conventional software project estimation techniques require estimates of lines-of-
code (LOC) or function points (FP) as the primary driver for estimation. Because an
overriding goal for OO projects should be reuse, LOC estimates make little sense. FP
estimates can be used effectively because the information domain counts that are
required are readily obtainable from the problem statement. FP analysis may provide
value for estimating OO projects, but the FP measure does not provide enough gran-
ularity for the schedule and effort adjustments that are required as we iterate through
the recursive/parallel paradigm.

These metrics can be
used to supplement
the FP metric. They
provide a way to
“size” an OO project.

XRef
A detailed discussion of
OO metrics is presented
in Chapter 24.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

563

Lorenz and Kidd [LOR94] suggest the following set of project metrics:6

Number of scenario scripts. A scenario script (analogous to use-cases dis-
cussed in Chapter 11) is a detailed sequence of steps that describe the inter-
action between the user and the application. Each script is organized into
triplets of the form
{initiator, action, participant} 

where initiator is the object that requests some service (that initiates a mes-
sage); action is the result of the request; and participant is the server object
that satisﬁes the request. The number of scenario scripts is directly correlated
to the size of the application and to the number of test cases that must be
developed to exercise the system once it is constructed.
Number of key classes. Key classes are the “highly independent compo-
nents” [LOR94] that are deﬁned early in OOA. Because key classes are central
to the problem domain, the number of such classes is an indication of the
amount of effort required to develop the software and also an indication of
the potential amount of reuse to be applied during system development.
Number of support classes. Support classes are required to implement the
system but are not immediately related to the problem domain. Examples
might be GUI classes, database access and manipulation classes, and com-
putation classes. In addition, support classes can be developed for each of
the key classes. Support classes are deﬁned iteratively throughout the recur-
sive/parallel process.

The number of support classes is an indication of the amount of effort

required to develop the software and also an indication of the potential
amount of reuse to be applied during system development. 
Average number of support classes per key class. In general, key
classes are known early in the project. Support classes are deﬁned through-
out. If the average number of support classes per key class were known for a
given problem domain, estimating (based on total number of classes) would
be much simpliﬁed. Lorenz and Kidd suggest that applications with a GUI
have between two and three times the number of support classes as key
classes. Non-GUI applications have between one and two times the number
of support classes as key classes.
Number of subsystems. A subsystem is an aggregation of classes that sup-
port a function that is visible to the end-user of a system. Once subsystems
are identiﬁed, it is easier to lay out a reasonable schedule in which work on
subsystems is partitioned among project staff.

6 Technical metrics for OO systems are discussed in detail in Chapter 24.

564

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

XRef
A number of software
project estimation
techniques are
considered in detail 
in Chapter 5.

20.4.3 An OO Estimating and Scheduling Approach
Software project estimation remains more art than science. However, this in no way
precludes the use of a systematic approach. To develop reasonable estimates it is
essential to develop multiple data points. That is, estimates should be derived using
a number of different techniques. Effort and duration estimates used for conventional
software development are applicable to the OO world, but the historical database for
OO projects is relatively small for many organizations. Therefore, it is worthwhile to
supplement conventional software cost estimation with an approach that has been
designed explicitly for OO software. Lorenz and Kidd [LOR94] suggest the following
approach:

1. Develop estimates using effort decomposition, FP analysis, and any other

method that is applicable for conventional applications.

2. Using OOA (Chapter 21), develop scenario scripts (use-cases) and determine

a count. Recognize that the number of scenario scripts may change as the
project progresses.

3. Using OOA, determine the number of key classes.
4. Categorize the type of interface for the application and develop a multiplier

for support classes:

Interface type
No GUI
Text-based user interface
GUI
Complex GUI

Multiplier
2.0
2.25
2.5
3.0

Multiply the number of key classes (step 3) by the multiplier to obtain an esti-
mate for the number of support classes.

5. Multiply the total number of classes (key + support) by the average number of

work-units per class. Lorenz and Kidd suggest 15 to 20 person-days per
class.

6. Cross check the class-based estimate by multiplying the average number of

work-units per scenario script.

Scheduling for object-oriented projects is complicated by the iterative nature of the
process framework. Lorenz and Kidd suggest a set of metrics that may assist during
project scheduling:

Number of major iterations. Thinking back to the spiral model (Chapter
2), a major iteration would correspond to one 360º traversal of the spiral. The
recursive/parallel process model would spawn a number of mini-spirals
(localized iterations) that occur as the major iteration progresses. Lorenz and

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

565

Kidd suggest that iterations of between 2.5 and 4 months in length are easi-
est to track and manage.
Number of completed contracts. A contract is “a group of related pub-
lic responsibilities that are provided by subsystems and classes to their
clients” [LOR94]. A contract is an excellent milestone and at least one con-
tract should be associated with each project iteration. A project manager
can use completed contracts as a good indicator of progress on an OO
project.

20.4.4 Tracking Progress for an OO Project
Although the recursive/parallel process model is the best framework for an OO pro-
ject, task parallelism makes project tracking difﬁcult. The project manager can have
difﬁculty establishing meaningful milestones for an OO project because a number of
different things are happening at once. In general, the following major milestones
can be considered “completed” when the criteria noted have been met.

Technical milestone:  OO analysis completed

• All classes and the class hierarchy have been deﬁned and reviewed.
• Class attributes and operations associated with a class have been deﬁned

and reviewed.

• Class relationships (Chapter 21) have been established and reviewed.
• A behavioral model (Chapter 21) has been created and reviewed.
• Reusable classes have been noted.

Technical milestone:  OO design completed

• The set of subsystems (Chapter 22) has been deﬁned and reviewed.
• Classes are allocated to subsystems and reviewed.
• Task allocation has been established and reviewed.
• Responsibilities and collaborations (Chapter 22) have been identiﬁed.
• Attributes and operations have been designed and reviewed.
• The messaging model has been created and reviewed.

Technical milestone:  OO programming completed

• Each new class has been implemented in code from the design model.
• Extracted classes (from a reuse library) have been implemented.
• Prototype or increment has been built.

Technical milestone:  OO testing

• The correctness and completeness of OO analysis and design models has

been reviewed.

566

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

• A class-responsibility-collaboration network (Chapter 23) has been devel-

oped and reviewed.

• Test cases are designed and class-level tests (Chapter 23) have been con-

ducted for each class.

• Test cases are designed and cluster testing (Chapter 23) is completed and the

classes are integrated.

• System level tests have been completed.

Recalling the recursive/parallel process model discussed earlier in this chapter, it is
important to note that each of these milestones may be revisited as different incre-
ments are delivered to the customer. 

20.5 SUMMARY

Object-oriented technologies reﬂect a natural view of the world. Objects are categorized
into classes and class hierarchies. Each class contains a set of attributes that describe it
and a set of operations that deﬁne its behavior. Objects model almost any identiﬁable
aspect of the problem domain. External entities, things, occurrences, roles, organiza-
tional units, places, and structures can all be represented as objects. As important, objects
(and the classes from which they are derived) encapsulate both data and process. Pro-
cessing operations are part of the object and are initiated by passing the object a mes-
sage. A class deﬁnition, once deﬁned, forms the basis for reusability at the modeling,
design, and implementation levels. New objects can be instantiated from a class.

Three important concepts differentiate the OO approach from conventional soft-
ware engineering. Encapsulation packages data and the operations that manipulate
the data into a single named object. Inheritance enables the attributes and opera-
tions of a class to be inherited by all subclasses and the objects that are instantiated
from them. Polymorphism enables a number of different operations to have the same
name, reducing the number of lines of code required to implement a system and facil-
itating changes when they are made. 

Object-oriented products and systems are engineered using an evolutionary model,
sometimes called a recursive/parallel model. OO software evolves iteratively and
must be managed with the recognition that the ﬁnal product will be developed over
a series of increments. 

REFERENCES

[BER93] Berard, E.V., Essays on Object-Oriented Software Engineering, Addison-
Wesley, 1993.
[BOO86] Booch, G., "Object-Oriented Development," IEEE Trans. Software Engineer-
ing, vol. SE-12, no. 2, February 1986, pp. 211ff. 

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

567

[BOO91] Booch, G., Object-Oriented Design, Benjamin Cummings, 1991.
[BUD96] Budd, T., An Introduction to Object-Oriented Programming, 2nd ed., Addison-
Wesley, 1996.
[CAS89] Cashman, M., "Object Oriented Domain Analysis," ACM Software Engineer-
ing Notes, vol. 14, no. 6, October 1989, p. 67.
[CHA93] de Champeaux, D., D. Lea, and P. Faure, Object-Oriented System Develop-
ment, Addison-Wesley, 1993. 
[COA91] Coad, P. and E. Yourdon, Object-Oriented Analysis, 2nd ed., Prentice-Hall,
1991.
[COX86] Cox, B.J., Object-Oriented Programming, Addison-Wesley, 1986.
[EVB89] Object-Oriented Requirements Analysis (course notebook), EVB Software
Engineering, 1989.
Jacobson, I., Object-Oriented Software Engineering, Addison-Wesley, 1992. 
[JAC92]
[LOR94] Lorenz, M. and J. Kidd, Object-Oriented Software Metrics, Prentice-Hall, 1994.
[STR88] Stroustrup, B., "What Is Object-Oriented Programming?" IEEE Software, vol.
5, no. 3, May 1988, pp. 10–20. 
[TAY90] Taylor, D.A., Object-Oriented Technology: A Manager’s Guide, Addison-
Wesley, 1990.

PROBLEMS AND POINTS TO PONDER

20.1. Object-oriented software engineering is rapidly displacing conventional soft-
ware development approaches. Yet, like all technologies, OO has flaws. Using the
Internet and hard-copy sources from your library, write a brief paper summarizing
what critics have to say about OO and why they believe care must be taken when
applying the OO paradigm.

20.2. In this chapter we did not consider the case in which a new object requires an
attribute or operation that is not contained in the class from which it inherited all
other attributes and operations. How do you think this is handled? 

20.3. Do some research and ﬁnd the real answer to Problem 20.2.

20.4. Using your own words and a few examples, deﬁne the terms class, encapsu-
lation, inheritance, and polymorphism.

20.5. Review the objects deﬁned for the SafeHome system. Are there other objects
that you feel should be deﬁned as modeling begins?

20.6. Consider a typical graphical user interface. Deﬁne a set of classes (and sub-
classes) for the interface entities that typically appear in the GUI. Be sure to deﬁne
appropriate attributes and operations.

20.7. Provide an example of a composite object.

568

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

20.8. You have been assigned the job of engineering new word-processing soft-
ware. A class named document is identiﬁed. Deﬁne the attributes and operations
that are relevant for document.

20.9. Research two different OO programming languages and show how messages
are implemented in the language syntax. Provide a few examples for each language.

20.10. Provide a concrete example of class hierarchy restructuring as described in
the discussion of Figure 20.8.

20.11. Provide a concrete example of multiple inheritance. Research one or more
papers on this subject and provide the pro and con arguments for multiple inheri-
tance.

20.12. Develop a statement of scope for a system requested by your instructor. Use
the grammatical parse to isolate candidate classes, attributes, and operations for the
system. Apply the selection criteria discussed in Section 20.3.1 to determine whether
the class should be used in the analysis model.

20.13. In your own words, describe why the recursive/parallel process model is
appropriate for OO systems.

20.14. Provide three or four specific examples of the key class and support class
described in Section 20.4.2.

FURTHER READINGS AND INFORMATION SOURCES

The explosion of interest in object-technologies has resulted in the publication of lit-
erally hundreds of books during the past 15 years. Taylor’s abbreviated treatment
[TAY90] remains a classic introduction to the subject. In addition, books by Ambler
(The Object Primer: The Application Developer's Guide to Object-Orientation, SIGS Books,
1998), Gossain and Graham (Object Modeling and Design Strategies, SIGS Books, 1998),
Bahar (Object Technology Made Simple, Simple Software Publishing, 1996), and Singer
(Object Technology Strategies and Tactics, Cambridge University Press, 1996) are worth-
while introductions to object-oriented concepts and methods.

Zamir (Handbook of Object Technology, CRC Press, 1998) has edited a voluminous
treatment that covers every aspect of object technologies. Fayad and Laitnen (Tran-
sition to Object-Oriented Software Development, Wiley, 1998) use case studies to iden-
tify technical, management, and cultural challenges that must be overcome when an
organization makes the transition to object technologies. Gardner et al. (Cognitive
Patterns: Problem-Solving Frameworks for Object Technology, Cambridge University
Press, 1998) provide the reader with a basic introduction to problem-solving concepts
and terminology associated with cognitive patterns and cognitive modeling as they
are applied to OO systems.

CHAPTER 20 OBJECT-ORIENTED CONCEPTS AND PRINCIPLES

569

The unique nature of the OO paradigm poses special challenges to project man-
agers. Books by Cockburn (Surviving Object-Oriented Projects: A Manager's Guide, 
Addison-Wesley, 1998), Booch (Object Solutions: Managing the Object-Oriented Pro-
ject, Addison-Wesley, 1995), Goldberg and Rubin (Succeeding with Objects: Decision
Frameworks for Project Management, Addison-Wesley, 1995), and Meyer (Object-Suc-
cess: A Manager’s Guide to Object-Orientation, Prentice-Hall, 1995) consider strategies
for planning, tracking, and controlling OO projects.

Eeles and Sims (Building Business Objects, Wiley, 1998), Carmichael (Developing
Business Objects, SIGS Books, 1998), Fingar (The Blueprint for Business Objects, Cam-
bridge University Press, 1996), and Taylor (Business Engineering with Object Technol-
ogy, Wiley, 1995) address object technology as it is applied in a business context. Their
books address methods for expressing business concepts and requirements directly
as objects and object-oriented applications.

A wide variety of information sources on object technologies and related subjects
is available on the Internet. An up-to-date list of World Wide Web references that are
relevant to OO can be found at the SEPA Web site:
http://www.mhhe.com/engcs/compsci/pressman/resources/
OO-concepts.mhtml

C H A P T E R

21 OBJECT-ORIENTED ANALYSIS
When a new product or system is to be built, how do we characterize

it in a way that is amenable to object-oriented software engineer-
ing? Are there special questions that we need to ask the customer?
What are the relevant objects? How do they relate to one another? How do
objects behave in the context of the system? How do we specify or model a
problem so that we can create an effective design? 

K E Y
C O N C E P T S
class diagrams  . 589
class taxonomy . 584
collaboration . . . 586
CRC modeling . . . 582
domain analysis. 576
object-behavior
model . . . . . . . . . 594
object-relationship
model . . . . . . . . . 591
OOA model
components . . . . 579
responsibilities. . 584
packages. . . . . . . 590
reuse . . . . . . . . . . 577
subsystems. . . . . 590
UML. . . . . . . . . . . 575
use-cases . . . . . . 581

Each of these questions is answered within the context of object-oriented
analysis (OOA)—the ﬁrst technical activity that is performed as part of OO soft-
ware engineering. Instead of examining a problem using the classic informa-
tion ﬂow model, OOA introduces a number of new concepts. Coad and Yourdon
[COA91] consider this issue when they write:

OOA—object-oriented analysis—is based upon concepts that we ﬁrst learned in kinder-
garten: objects and attributes, classes and members, wholes and parts. Why it has
taken us so long to apply these concepts to the analysis and speciﬁcation of infor-
mation systems is anyone's guess . . .

OOA is grounded in a set of basic principles that were introduced in Chapter 11.
In  order  to  build  an  analysis  model,  five  basic  principles  were  applied: 
(1) the information domain is modeled; (2) function is described; (3) behavior is

Q U I C K
L O O K

to  define 

What is it? Before you can build
an object-oriented system, you
the  classes
have 
(objects) that represent the problem to be solved,
the manner in which the classes relate to and
interact with one another, the inner workings
(attributes and operations) of objects, and the com-
munication mechanisms (messages) that allow
them to work together. All of these things are
accomplished  during  object-oriented  analysis
(OOA).

Who does it? The definition of an object-oriented
analysis model encompasses a description of the
static and dynamic characteristics of classes that
describe a system or product. This activity is per-
formed by a software engineer.

Why is it important? You can’t build software (object-
oriented or otherwise) until you have a reason-
able understanding of the system or product. OOA
provides you with a concrete way to represent
your understanding of requirements and then test
that understanding against the customer’s per-
ception of the system to be built.

What are the steps? OOA begins with a description
of  use-cases—a  scenario-based  description  of 
how actors (people, machines, other systems) 
interact  with  the  product  to  be  built.  Class-
responsibility-collaborator (CRC) modeling trans-
lates the information contained in use-cases into
a representation of classes and their collabora-
tions with other classes. The static and dynamic
characteristics of classes are then modeled using

571

572

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Q U I C K
L O O K

a uniﬁed modeling language (or
some other method).
What is the work product? An
object-oriented analysis model is created. The OO
analysis  model  is  composed  of  graphical  or 
language-based representations that deﬁne class
attributes, relationships, and behaviors, as well as

interclass communication and a depiction of class
behavior over time.

How do I ensure that I’ve done it right? At each stage,
the elements of the object-oriented analysis model
are reviewed for clarity, correctness, complete-
ness, and consistency with customer requirements
and with one another.

represented; (4) data, functional, and behavioral models are partitioned to expose
greater detail; and (5) early models represent the essence of the problem while later
models provide implementation details. These principles form the foundation for the
approach to OOA presented in this chapter.

The intent of OOA is to deﬁne all classes that are relevant to the problem to be
solved—the operations and attributes associated with them, the relationships between
them, and behavior they exhibit. To accomplish this, a number of tasks must occur:

1. Basic user requirements must be communicated between the customer and

the software engineer.

“A problem well-
stated is a problem
half-solved.”
Charles Kettering 

2. Classes must be identiﬁed (i.e., attributes and methods are deﬁned).
3. A class hierarchy must be speciﬁed.
4. Object-to-object relationships (object connections) should be represented.
5. Object behavior must be modeled.
6. Tasks 1 through 5 are reapplied iteratively until the model is complete.

It is important to note that there is no universal agreement on the "concepts" that
serve as a foundation for OOA. But a limited number of key ideas appear repeatedly,
and it is these that we will consider in this chapter.

21.1 OBJECT-ORIENTED ANALYSIS

The objective of object-oriented analysis is to develop a model that describes com-
puter software as it works to satisfy a set of customer-deﬁned requirements. OOA,
like the conventional analysis methods described in Chapter 12, builds a multipart
analysis model to satisfy this objective. The analysis model depicts information, func-
tion, and behavior within the context of the elements of the object model described
in Chapter 20. 

21.1.1 Conventional vs. OO Approaches
Is object-oriented analysis really different from the structured analysis approach that
was presented in Chapter 12? Fichman and Kemerer [FIC92] address the question
head-on:

?

What 
criteria can

be used to
compare
conventional and
OOA methods?

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

573

We conclude that the object-oriented analysis approach . . . represents a radical change over
process oriented methodologies such as structured analysis, but only an incremental change
over data oriented methodologies such as information engineering. Process-oriented method-
ologies focus attention away from the inherent properties of objects during the modeling
process and lead to a model of the problem domain that is orthogonal to the three essential
principles of object-orientation: encapsulation, classiﬁcation of objects, and inheritance.

Stated simply, structured analysis (SA) takes a distinct input-process-output view of
requirements. Data are considered separately from the processes that transform the
data. System behavior, although important, tends to play a secondary role in struc-
tured analysis. The structured analysis approach makes heavy use of functional decom-
position (partitioning of the data ﬂow diagram, Chapter 12).

Fichman and Kemerer [FIC92] suggest 11 “modeling dimensions” that may be used

to compare various conventional and object-oriented analysis methods:

Identiﬁcation/classiﬁcation of entities1

1.
2. General-to-speciﬁc and whole-to-part entity relationships
3. Other entity relationships
4. Description of attributes of entities
5. Large-scale model partitioning
6. States and transitions between states
7. Detailed speciﬁcation for functions
8. Top-down decomposition
9. End-to-end processing sequences
Identiﬁcation of exclusive services

10.
11. Entity communication (via messages or events)

Because many variations exist for structured analysis and dozens of OOA methods (see
Section 21.1.2) have been proposed over the years, it is difﬁcult to develop a general-
ized comparison between the two methods. It can be stated, however, that modeling
dimensions 8 and 9 are always present with SA and never present when OOA is used.

21.1.2 The OOA Landscape
The popularity of object technologies spawned dozens of OOA methods during the
late 1980s and into the 1990s.2 Each of these introduced a process for the analysis

1 In this context, entity refers to either a data object (in the structured analysis sense) or an object

(in the OOA sense).

2 A detailed discussion of these methods and their differences is beyond the scope of this book. In
addition, the industry is moving toward a uniﬁed method of analysis modeling, making a detailed
discussion of older methods useful for historical purposes only. The interested reader should refer
to Berard [BER99] and Graham [GRA94] for detailed comparisons.

574

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

of a product or system, a set of diagrams that evolved out of the process, and a nota-
tion that enabled the software engineer to create the analysis model in a consistent
manner. Among the most widely used were3

“The central activity
of working with
objects is not so
much a matter of
programming as it is
representation.”
David Taylor 

The Booch method. The Booch method [BOO94] encompasses both a
“micro development process” and a “macro development process.” The micro
level deﬁnes a set of analysis tasks that are reapplied for each step in the
macro process. Hence, an evolutionary approach is maintained.  Booch’s OOA
micro development process identiﬁes classes and objects and the semantics of
classes and objects and deﬁnes relationships among classes and objects and
conducts a series of reﬁnements to elaborate the analysis model.
The Rumbaugh method. Rumbaugh [RUM91] and his colleagues devel-
oped the object modeling technique (OMT) for analysis, system design, and
object-level design. The analysis activity creates three models: the object
model (a representation of objects, classes, hierarchies, and relationships),
the dynamic model (a representation of object and system behavior), and the
functional model (a high-level DFD-like representation of information ﬂow
through the system). 
The Jacobson method. Also called OOSE (object-oriented software engi-
neering), the Jacobson method [JAC92] is a simpliﬁed version of the propri-
etary objectory method, also developed by Jacobson. This method is
differentiated from others by heavy emphasis on the use-case—a description
or scenario that depicts how the user interacts with the product or system.  
The Coad and Yourdon method. The Coad and Yourdon method [COA91]
is often viewed as one of the easiest OOA methods to learn. Modeling nota-
tion is relatively simple and guidelines for developing the analysis model are
straightforward.  A brief outline of Coad and Yourdon’s OOA process follows:

• Identify objects using “what to look for” criteria.
• Deﬁne a generalization/speciﬁcation structure.
• Deﬁne a whole/part structure.
• Identify subjects (representations of subsystem components).
• Deﬁne attributes.
• Deﬁne services.

The Wirfs-Brock method. Wirfs-Brock, Wilkerson, and Weiner [WIR90] do
not make a clear distinction between analysis and design tasks. Rather a
continuous process that begins with the assessment of a customer speciﬁca-
tion and ends with design is proposed. A brief outline of Wirfs-Brock et al.'s
analysis-related tasks follows: 

3 In general, OOA methods are identiﬁed using the name(s) of the developer of the method, even if

the method has been given a unique name or acronym.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

575

• Evaluate the customer speciﬁcation.
• Extract candidate classes from the speciﬁcation via grammatical parsing.
• Group classes in an attempt to identify superclasses.
• Deﬁne responsibilities for each class.
• Assign responsibilities to each class.
• Identify relationships between classes.
• Deﬁne collaboration between classes based on responsibilities.
• Build hierarchical representations of classes.
• Construct a collaboration graph for the system.

Although the terminology and process steps for each of these OOA methods dif-
fer, the overall OOA processes are really quite similar. To perform object-oriented
analysis, a software engineer should perform the following generic steps:

Identify scenarios or use-cases.

Identify attributes and operations for each system object.

1. Elicit customer requirements for the system.
2.
3. Select classes and objects using basic requirements as a guide.
4.
5. Deﬁne structures and hierarchies that organize classes.
6. Build an object-relationship model.
7. Build an object-behavior model.
8. Review the OO analysis model against use-cases or scenarios.

These generic steps are considered in greater detail in Sections 21.3 and 21.4.

21.1.3 A Uniﬁed Approach to OOA
Over the past decade, Grady Booch, James Rumbaugh, and Ivar Jacobson have col-
laborated to combine the best features of their individual object-oriented analysis
and design methods into a unified method. The result, called the Unified Modeling
Language (UML), has become widely used throughout the industry.4

UML allows a software engineer to express an analysis model using a modeling
notation that is governed by a set of syntactic, semantic, and pragmatic rules. Eriks-
son and Penker [ERI98] explain these rules in the following way:

The syntax tells us how the symbols should look and how the symbols are combined.
The syntax is compared to words in natural language; it is important to know how to spell
them correctly and how to put different words together to form a sentence. The semantic
rules tell us what each symbol means and how it should be interpreted by itself and in the
context of other symbols; they are compared to the meanings of words in a natural language.

4 Booch, Rumbaugh, and Jacobson have written a set of three deﬁnitive books on UML. The inter-

ested reader should see [BOO99], [RUM99], and [JAC99].

A set of generic steps
are applied during
OOA, regardless of the
analysis method that is
chosen.

“UML has uniﬁed
some of the existing
OO notations, thus
creating a single
point of reference for
many important
concepts.”
Peter Hruschka 

576

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The pragmatic rules deﬁne the intentions of the symbols through which the purpose of
the model is achieved and becomes understandable for others. This corresponds in natural
language to the rules for constructing sentences that are clear and understandable. 

In UML, a system is represented using ﬁve different “views” that describe the system
from distinctly different perspectives. Each view is deﬁned by a set of diagrams. The
following views [ALH98] are present in UML:

User model view. This view represents the system (product) from the
user’s (called actors in UML) perspective. The use-case is the modeling
approach of choice for the user model view. This important analysis repre-
sentation describes a usage scenario from the end-user's perspective and has
been discussed in detail in Chapter 11.5
Structural model view. Data and functionality are viewed from inside 
the system. That is, static structure (classes, objects, and relationships) is
modeled.
Behavioral model view. This part of the analysis model represents the
dynamic or behavioral aspects of the system. It also depicts the interactions
or collaborations between various structural elements described in the user
model and structural model views. 
Implementation model view. The structural and behavioral aspects of the
system are represented as they are to be built.
Environment model view. The structural and behavioral aspects of the
environment in which the system is to be implemented are represented.

In general, UML analysis modeling focuses on the user model and structural model
views of the system. UML design modeling (considered in Chapter 22) addresses the
behavioral model, implementation model, and environmental model views. 

Like all analysis
approaches,
requirements
elicitation is key. Be
certain that you get
the user model view
right. The rest will
follow.

WebRef
An extensive tutorial and
listing of UML resources
including tools, papers,
and examples can be
found at
mini.net/cetus/
oo_uml.html

21.2 DOMAIN ANALYSIS

Analysis for object-oriented systems can occur at many different levels of abstrac-
tion. At the business or enterprise level, the techniques associated with OOA can be
coupled with a business process engineering approach (Chapter 10) in an effort to
deﬁne classes, objects, relationships, and behaviors that model the entire business.
At the business area level, an object model that describes the workings of a particu-
lar business area (or a category of products or systems) can be deﬁned. At an appli-
cation level, the object model focuses on specific customer requirements as those
requirements affect an application to be built.

OOA at the highest level of abstraction (the enterprise level) is beyond the scope
of this book. Interested readers should see [EEL98], [CAR98], [FIN96], [TAY95], [MAT94],

5 If you have not already done so, please read Section 11.2.4 for a detailed discussion of use-cases.

The objective of
domain analysis is to
deﬁne a set of classes
(objects) that are
encountered
throughout an
application domain.
These can then be
reused in many
applications.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

577

and [SUL94] for detailed discussions of enterprise-level modeling. OOA at the low-
est level of abstraction falls within the general purview of object-oriented software
engineering and is the focus of all other sections of this chapter. In this section, we
conducted OOA at a middle level of abstraction. This activity, called domain analysis,
is performed when an organization wants to create a library of reusable classes (com-
ponents) that will be broadly applicable to an entire category of applications.

21.2.1 Reuse and Domain Analysis
Object-technologies are leveraged through reuse. Consider a simple example. The
analysis of requirements for a new application indicates that 100 classes are needed.
Two teams are assigned to build the application. Each will design and construct a
ﬁnal product. Each team is populated by people with the same skill levels and expe-
rience.

Team A does not have access to a class library, and therefore, it must develop all
100 classes from scratch. Team B uses a robust class library and ﬁnds that 55 classes
already exist. It is highly likely that

1. Team B will ﬁnish the project much sooner than Team A.
2. The cost of Team B’s product will be signiﬁcantly lower than the cost of Team

A’s product.

3. The product produced by Team B will have fewer delivered defects than

Team A’s product.

Although the margin by which Team B’s work would exceed Team A’s accomplish-
ments is open to debate, few would argue that reuse provides Team B with a sub-
stantial advantage.

But where did the “robust class library” come from? How were the entries in the
library determined to be appropriate for use in new applications? To answer these
questions, the organization that created and maintained the library had to apply
domain analysis.

21.2.2 The Domain Analysis Process
Firesmith [FIR93] describes software domain analysis in the following way:

Software domain analysis is the identiﬁcation, analysis, and speciﬁcation of common require-
ments from a specific application domain, typically for reuse on multiple projects within
that application domain . . . [Object-oriented domain analysis is] the identiﬁcation, analy-
sis, and speciﬁcation of common, reusable capabilities within a speciﬁc application domain,
in terms of common objects, classes, subassemblies, and frameworks . . .

The “speciﬁc application domain” can range from avionics to banking, from multi-
media video games to applications within an MRI device. The goal of domain analy-
sis is straightforward: to ﬁnd or create those classes that are broadly applicable, so
that they may be reused.

Other beneﬁts derived
from reuse are
consistency and
familiarity. Patterns
within the software
will become more
consistent, leading to
better maintainability.
Be certain to establish
a set of reuse “design
rules” so that these
beneﬁts are achieved.

XRef
Reuse is the
cornerstone of
component-based
software engineering, a
topic discussed in 
Chapter 27.

578

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Sources of
domain

knowledge

Technical literature
Existing applications
Customer surveys
Expert advice
Current/future requirements

Domain
analysis

Class taxonomies
Reuse standards
Functional models
Domain languages

Domain
analysis
model

FIGURE 21.1 Input and output for domain analysis

Using terminology that was introduced earlier in this book, domain analysis may
be viewed as an umbrella activity for the software process. By this we mean that
domain analysis is an ongoing software engineering activity that is not connected to
any one software project. In a way, the role of a domain analyst is similar to the role
of a master toolsmith in a heavy manufacturing environment. The job of the tool-
smith is to design and build tools that may be used by many people doing similar but
not necessarily the same jobs. The role of the domain analyst is to design and build
reusable components that may be used by many people working on similar but not
necessarily the same applications.

Figure 21.1 [ARA89] illustrates key inputs and outputs for the domain analysis
process. Sources of domain knowledge are surveyed in an attempt to identify objects
that can be reused across the domain. In essence domain analysis is quite similar to
knowledge engineering. The knowledge engineer investigates a speciﬁc area of inter-
est in an attempt to extract key facts that may be of use in creating an expert system
or artificial neural network. During domain analysis, object (and class) extraction
occurs.

The domain analysis process can be characterized by a series of activities that
begin with the identiﬁcation of the domain to be investigated and end with a speci-
ﬁcation of the objects and classes that characterize the domain. Berard [BER93] sug-
gests the following activities:

Deﬁne the domain to be investigated. To accomplish this, the analyst
must ﬁrst isolate the business area, system type, or product category of inter-
est. Next, both OO and non-OO “items” must be extracted. OO items include
speciﬁcations, designs, and code for existing OO application classes; support
classes (e.g., GUI classes or database access classes); commercial off-the-
shelf (COTS) component libraries that are relevant to the domain; and test
cases. Non-OO items encompass policies, procedures, plans, standards, and
guidelines; parts of existing non-OO applications (including speciﬁcation,
design, and test information); metrics; and COTS non-OO software.
Categorize the items extracted from the domain. The items are orga-
nized into categories and the general deﬁning characteristics of the category
are deﬁned. A classiﬁcation scheme for the categories is proposed and nam-

“If an organization is
to make a major
investment in
software reuse, it
needs to know what
components to
consider in the
development of such
a model.”
David Rine 

XRef
A complete domain
analysis strategy must
consider architecture as
well as components. A
detailed discussion of
software architecture is
presented in Chapter
14.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

579

ing conventions for each item are deﬁned. When appropriate, classiﬁcation
hierarchies are established.
Collect a representative sample of applications in the domain. To
accomplish this activity, the analyst must ensure that the application in ques-
tion has items that ﬁt into the categories that have already been deﬁned. Berard
[BER93] notes that during the early stages of use of object-technologies, a soft-
ware organization will have few if any OO applications. Therefore, the domain
analyst must “identify the conceptual (as opposed to physical) objects in each
[non-OO] application.”
Analyze each application in the sample. The following steps [BER93] are
followed by the analyst:

• Identify candidate reusable objects.
• Indicate the reasons that the object has been identiﬁed for reuse.
• Deﬁne adaptations to the object that may also be reusable.
• Estimate the percentage of applications in the domain that might make

reuse of the object.

• Identify the objects by name and use conﬁguration management 

techniques (Chapter 9) to control them. In addition, once the objects
have been deﬁned, the analyst should estimate what percentage 
of a typical application could be constructed using the reusable 
objects.

Develop an analysis model for the objects. The analysis model will
serve as the basis for design and construction of the domain objects.

WebRef
A worthwhile tutorial on
domain  analysis can be
found at 
www.sei.cmu.edu/
str/descriptions/
deda.html

In addition to these steps, the domain analyst should also create a set of reuse
guidelines and develop an example that illustrates how the domain objects could be
used to create a new application.

Domain analysis is the ﬁrst technical activity in a broader discipline that some call
domain engineering. When a business, system, or product domain is defined to be
business strategic in the long term, a continuing effort to create a robust reuse library
can be undertaken. The goal is to be able to create software within the domain with
a very high percentage of reusable components. Lower cost, higher quality, and
improved time to market are the arguments in favor of a dedicated domain engi-
neering effort.

21.3 GENERIC COMPONENTS OF THE OO ANALYSIS

MODEL

The  object-oriented  analysis  process  conforms  to  the  basic  analysis  concepts 
and principles discussed in Chapter 11. Although the terminology, notation, and 

580

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

activities differ from conventional methods, OOA (at its kernel) addresses the same
underlying objectives. Rumbaugh et al. [RUM91] discuss this when they state:

Analysis . . . is concerned with devising a precise, concise, understandable, and correct
model of the real world. . . . The purpose of object-oriented analysis is to model the real
world so that it can be understood. To do this, you must examine requirements, analyze
their implications, and restate them rigorously. You must abstract real-world features ﬁrst,
and defer small details until later.

To develop a “precise, concise, understandable, and correct model of the real world,”
a software engineer must select a notation that implements a set of generic compo-
nents of an OO analysis model. Monarchi and Puhr [MON92] deﬁne a set of generic
representational components that appear in all OO analysis models.6 Static compo-
nents are structural in nature and indicate characteristics that hold throughout the
operational life of an application. These characteristics distinguish one object from
other objects. Dynamic components focus on control and are sensitive to timing and
event processing. They deﬁne how one object interacts with other objects over time.
The following components are identiﬁed [MON92]:

Static view of semantic classes. A taxonomy of typical classes was identi-
ﬁed in Chapter 20. Requirements are assessed and classes are extracted (and
represented) as part of the analysis model. These classes persist throughout
the life of the application and are derived based on the semantics of the cus-
tomer requirements.  
Static view of attributes. Every class must be explicitly described. The
attributes associated with the class provide a description of the class, as well
as a ﬁrst indication of the operations that are relevant to the class.
Static view of relationships. Objects are “connected” to one another in a
variety of ways. The analysis model must represent these relationships so
that operations (that affect these connections) can be identiﬁed and the
design of a messaging approach can be accomplished.
Static view of behaviors. The relationships just noted deﬁne a set of
behaviors that accommodate the usage scenario (use-cases) of the system.
These behaviors are implemented by deﬁning a sequence of operations that
achieve them.
Dynamic view of communication. Objects must communicate with one
another and do so based on a series of events that cause transition from one
state of a system to another
Dynamic view of control and time. The nature and timing of events that
cause transitions among states must be described.

6 The authors [MON92] also provide an analysis of 23 early OOA methods and indicate how they

address these components.

?

What are the
key

components of an
OOA model?

Static components do
not change as the
application is executed.
Dynamic components
are inﬂuenced by
timing and events.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

581

De Champeaux, Lea, and Faure [CHA93] deﬁne a slightly different view of OOA
representations. Static and dynamic components are identiﬁed for object internals
and for interobject representations. A dynamic view of object internals can be char-
acterized as an object life history; that is, the states of the object change over time as
various operations are performed on its attributes.

21.4 THE OOA PROCESS

XRef
Use-cases are an
excellent requirements
elicitation tool,
regardless of the
analysis method that is
used. See Chapter 11
for additional
information.

The OOA process does not begin with a concern for objects. Rather, it begins with
an understanding of the manner in which the system will be used—by people, if the
system is human-interactive; by machines, if the system is involved in process con-
trol; or by other programs, if the system coordinates and controls applications. Once
the scenario of usage has been deﬁned, the modeling of the software begins.

The sections that follow deﬁne a series of techniques that may be used to gather
basic customer requirements and then define an analysis model for an object-
oriented system. 

21.4.1 Use-Cases 
As we noted in Chapter 11, use-cases model the system from the end-user’s point of
view. Created during requirements elicitation, use-cases should achieve the follow-
ing objectives:

• To deﬁne the functional and operational requirements of the system (product)

by deﬁning a scenario of usage that is agreed upon by the end-user and the
software engineering team.

• To provide a clear and unambiguous description of how the end-user and the

system interact with one another.

• To provide a basis for validation testing.

During OOA, use-cases serve as the basis for the ﬁrst element of the analysis model. 
Using UML notation, a diagrammatic representation of a use-case, called a use-case
diagram, can be created. Like many elements of the analysis model, the use-case dia-
gram can be represented at many levels of abstraction. The use-case diagram contains
actors and use-cases. Actors are entities that interact with the system. They can be
human users or other machines or systems that have deﬁned interfaces to the software.
To illustrate the development of a use-case diagram, we consider the use-cases
for the SafeHome security system described in Section 11.2.4. Three actors were iden-
tiﬁed: the homeowner, sensors, and the monitoring and response subsystem.
For the purpose of this example, only the homeowner is considered.

Figure 21.2A depicts a high-level use-case diagram for the homeowner. Refer-
ring to Figure 21.2A, two use-cases are identiﬁed (represented by ovals). Each of the
high-level use-cases may be elaborated with lower-level use-case diagrams. For

582

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 21.2
(A) High-level
use-case 
diagram, (B)
elaborated
use-case 
diagram

SafeHome

Interacts

Homeowner

Configures

(A)

Inputs

password

<<uses>>

Validates
password

Inquires

zone status

<<uses>>

Inquires

sensor status

<<uses>>

Query
sensor

Homeowner

Presses

panic button

Activates/
deactivates

system 

(B)

example, Figure 21.2B represents a use-case diagram that elaborates the interacts
function. A complete set of use-case diagrams is created for all actors. A detailed dis-
cussion of use-case modeling using UML is best left to books (e.g., [ERI98], [ALH98])
dedicated to this OOA method.

21.4.2 Class-Responsibility-Collaborator Modeling
Once basic usage scenarios have been developed for the system, it is time to iden-
tify candidate classes and indicate their responsibilities and collaborations. Class-
responsibility-collaborator (CRC) modeling [WIR90] provides a simple means for
identifying and organizing the classes that are relevant to system or product require-
ments. Ambler [AMB95] describes CRC modeling in the following way:

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

583

A CRC model is really a collection of standard index cards that represent classes. The cards
are divided into three sections. Along the top of the card you write the name of the class.
In the body of the card you list the class responsibilities on the left and the collaborators on
the right.

In reality, the CRC model may make use of actual or virtual index cards. The intent is
to develop an organized representation of classes. Responsibilities are the attributes
and operations that are relevant for the class. Stated simply, a responsibility is “any-
thing the class knows or does” [AMB95]. Collaborators are those classes that are
required to provide a class with the information needed to complete a responsibility.
In general, a collaboration implies either a request for information or a request for
some action.

Classes

Basic guidelines for identifying classes and objects were presented in Chapter 20. To
summarize, objects manifest themselves in a variety of forms (Section 20.3.1): exter-
nal entities, things, occurrences, or events; roles; organizational units; places; or
structures. One technique for identifying these in the context of a software problem
is to perform a grammatical parse on the processing narrative for the system. All
nouns become potential objects. However, not every potential object makes the cut.
Six selection characteristics were deﬁned:

1. Retained information. The potential object will be useful during analysis

only if information about it must be remembered so that the system can
function.

2. Needed services. The potential object must have a set of identiﬁable opera-

tions that can change the value of its attributes in some way.

3. Multiple attributes. During requirements analysis, the focus should be on
"major" information; an object with a single attribute may, in fact, be useful
during design but is probably better represented as an attribute of another
object during the analysis activity.

4. Common attributes. A set of attributes can be deﬁned for the potential

object and these attributes apply to all occurrences of the object.

5. Common operations. A set of operations can be deﬁned for the potential

object and these operations apply to all occurrences of the object.

6. Essential requirements. External entities that appear in the problem space
and produce or consume information that is essential to the operation of any
solution for the system will almost always be deﬁned as objects in the
requirements model.

A potential object should satisfy all six of these selection characteristics if it is to be
considered for inclusion in the CRC model.

?

How do I
determine

whether a
potential object is
worthy of
inclusion on a CRC
index card?

584

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Firesmith [FIR93] extends this taxonomy of class types by suggesting the follow-

ing additions:

?

Is there a
way to
categorize
classes, and what
characteristics
help us do this?

Device classes model external entities such as sensors, motors, keyboards.
Property classes represent some important property of the problem 
environment (e.g., credit rating within the context of a mortgage loan 
application).
Interaction classes  model interactions that occur among other objects
(e.g., a purchase or a license).

In addition, objects and classes may be categorized by a set of characteristics:

Tangibility. Does the class represent a tangible thing (e.g., a keyboard or
sensor) or does it represent more abstract information (e.g., a predicted 
outcome)?
Inclusiveness. Is the class atomic (i.e., it includes no other classes) or is it
aggregate (it includes at least one nested object)?
Sequentiality. Is the class concurrent (i.e., it has its own thread of control)
or sequential (it is controlled by outside resources)? 
Persistence. Is the class transient (i.e., it is created and removed during pro-
gram operation), temporary (it is created during program operation and
removed once the program terminates), or permanent (it is stored in a 
database)? 
Integrity. Is the class corruptible (i.e., it does not protect its resources from
outside inﬂuence) or guarded (i.e., the class enforces controls on access to its
resources)? 

Using these class categories, the “index card” created as part of the CRC model
might be extended to include the type of class and its characteristics (Figure 21.3).

Responsibilities

Basic guidelines for identifying responsibilities (attributes and operations) were also
presented in Chapter 20. To summarize, attributes represent stable features of a class;
that is, information about the class that must be retained to accomplish the objec-
tives of the software speciﬁed by the customer. Attributes can often be extracted from
the statement of scope or discerned from an understanding of the nature of the class.
Operations can be extracted by performing a grammatical parse on the processing
narrative for the system. All verbs become candidate operations. Each operation that
is chosen for a class exhibits a behavior of the class.

Wirfs-Brock and her colleagues [WIR90] suggest five guidelines for allocating

responsibilities to classes:

The responsibilities of a
class encompass both
attributes and
operations.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

585

FIGURE 21.3
A CRC model
index card

Class name:

Class type: (e.g., device, property, role, event)

Class characteristic: (e.g., tangible, atomic, concurrent)

responsibilities:

collaborations:

?

How do I
allocate

responsibilities to
a class?

If a class has an
extraordinarily long list
of responsibilities, you
should consider
partitioning its
deﬁnition into more
than one class.

1. System intelligence should be evenly distributed. Every application

encompasses a certain degree of intelligence; that is, what the system
knows and what it can do. This intelligence can be distributed across
classes in a number of different ways. “Dumb” classes (those that have few
responsibilities) can be modeled to act as servants to a few “smart” classes
(those having many responsibilities. Although this approach makes the ﬂow
of control in a system straightforward, it has a few disadvantages: (1) It con-
centrates all intelligence within a few classes, making changes more difﬁ-
cult, and (2) it tends to require more classes, hence more development
effort.

Therefore, system intelligence should be evenly distributed across the

classes in an application. Because each object knows about and does only
a few things (that are generally well focused), the cohesiveness of the sys-
tem is improved. In addition, side effects due to change tend to be damp-
ened because system intelligence has been decoupled across many
objects.

To determine whether system intelligence is evenly distributed, the

responsibilities noted on each CRC model index card should be evaluated to
determine if any class has an extraordinarily long list of responsibilities. This
indicates a concentration of intelligence. In addition, the responsibilities for
each class should exhibit the same level of abstraction. For example, among
the operations listed for an aggregate class called checking account a
reviewer notes two responsibilities: balance-the-account and check-off-

586

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

cleared-checks. The ﬁrst operation (responsibility) implies a complex mathe-
matical and logical procedure. The second is a simple clerical activity. Since
these two operations are not at the same level of abstraction, check-off-
cleared-checks should be placed within the responsibilities of check-entry, a
class that is encompassed by the aggregate class checking account. 

2. Each responsibility should be stated as generally as possible. This

3.

4.

guideline implies that general responsibilities (both attributes and operations)
should reside high in the class hierarchy (because they are generic, they will
apply to all subclasses). In addition, polymorphism (Chapter 20) should be
used in an effort to deﬁne operations that generally apply to the superclass
but are implemented differently in each of the subclasses.
Information and the behavior related to it should reside within the
same class. This achieves the OO principle that we have called encapsula-
tion (Chapter 20). Data and the processes that manipulate the data should be
packaged as a cohesive unit. 
Information about one thing should be localized with a single class,
not distributed across multiple classes. A single class should take on the
responsibility for storing and manipulating a speciﬁc type of information. This
responsibility should not, in general, be shared across a number of classes. If
information is distributed, software becomes more difﬁcult to maintain and
more challenging to test.

5. Responsibilities should be shared among related classes, when

appropriate. There are many cases in which a variety of related objects
must all exhibit the same behavior at the same time. As an example, consider
a video game that must display the following objects: player, player-body,
player-arms, player-legs, player-head. Each of these objects has its own
attributes (e.g., position, orientation, color, speed) and all must be updated and
displayed as the user manipulates a joy stick. The responsibilities update and
display must therefore be shared by each of the objects noted. Player knows
when something has changed and update is required. It collaborates with the
other objects to achieve a new position or orientation, but each object con-
trols its own display.

Collaborations

Classes fulfill their responsibilities in one of two ways: (1) A class can use its own
operations to manipulate its own attributes, thereby fulﬁlling a particular responsi-
bility, or (2) a class can collaborate with other classes.

Wirfs-Brock and her colleagues [WIR90] deﬁne collaborations in the following way:

Collaborations represent requests from a client to a server in fulﬁllment of a client respon-
sibility. A collaboration is the embodiment of the contract between the client and the server.
. . . We say that an object collaborates with another object if, to fulfill a responsibility, it

A server object
collaborates with a
client object in an
effort to fulﬁll some
responsibility. The
collaboration involves
the passing of
messages.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

587

needs to send the other object any messages. A single collaboration ﬂows in one direction—
representing a request from the client to the server. From the client’s point of view, each of
its collaborations are associated with a particular responsibility implemented by the server.

Collaborations identify relationships between classes. When a set of classes all col-
laborate to achieve some requirement, they can be organized into a subsystem (a
design issue). 

Collaborations are identiﬁed by determining whether a class can fulﬁll each respon-
sibility itself. If it cannot, then it needs to interact with another class. Hence, a col-
laboration. 

As an example, consider the SafeHome application.7 As part of the activation pro-
cedure (see the use-case for activation in Section 11.2.4), the control panel object
must determine whether any sensors are open. A responsibility named determine-
sensor-status is deﬁned.  If sensors are open control panel must set a status attribute
to “not ready.” Sensor information can be acquired from the sensor object. There-
fore, the responsibility determine-sensor-status can be fulﬁlled only if control panel
works in collaboration with sensor.

To help in the identiﬁcation of collaborators, the analyst can examine three dif-
ferent generic relationships between classes [WIR90]: (1) the is-part-of relationship,
(2) the has-knowledge-of relationship, and (3) the depends-upon relationship. By cre-
ating a class-relationship diagram (Section 21.4.4), the analyst develops the con-
nections necessary to identify these relationships. Each of the three generic relations
is considered brieﬂy in the paragraphs that follow.

All classes that are part of an aggregate class are connected to the aggregate class
via an is-part-of relationship. Consider the classes deﬁned for the video game noted
earlier, the class player-body is-part-of player, as are player-arms, player-legs,
and player-head.

When one class must acquire information from another class, the has-knowledge-
of relationship is established. The determine-sensor-status responsibility noted ear-
lier is an example of a has-knowledge-of relationship.

The depends-upon relationship implies that two classes have a dependency that
is not achieved by has-knowledge-of or is-part-of. For example, player-head must
always be connected to player-body (unless the video game is particularly violent),
yet each object could exist without direct knowledge of the other. An attribute of the
player-head object called center-position is determined from the center position of
player-body. This information is obtained via a third object, player, that acquires it
from player-body. Hence, player-head depends-upon player-body.

In all cases, the collaborator class name is recorded on the CRC model index card
next to the responsibility that has spawned the collaboration. Therefore, the index
card contains a list of responsibilities and the corresponding collaborations that enable
the responsibilities to be fulﬁlled (Figure 21.3).

7 See Section 20.3 for a delineation of classes for SafeHome.

588

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

?

What is an
effective
approach for
reviewing a CRC
model?

When a complete CRC model has been developed, the representatives from the
customer and software engineering organizations can review the model using the
following approach [AMB95]:

1. All participants in the review (of the CRC model) are given a subset of the

CRC model index cards. Cards that collaborate should be separated (i.e., no
reviewer should have two cards that collaborate).

2. All use-case scenarios (and corresponding use-case diagrams) should be

organized into categories.

3. The review leader reads the use-case deliberately. As the review leader

comes to a named object, she passes a token to the person holding the corre-
sponding class index card. For example, a use-case for SafeHome contains
the following narrative:

The homeowner observes the SafeHome control panel to determine if the system is
ready for input. If the system is not ready, the homeowner must physically close
windows/doors so that the ready indicator is present. [A not-ready indicator implies
that a sensor is open, i.e., that a door or window is open.]

When the review leader comes to “control panel,” in the use-case narrative,
the token is passed to the person holding the control panel index card. The
phrase “implies that a sensor is open” requires that the index card contains a
responsibility that will validate this implication (the responsibility determine-
sensor-status accomplishes this). Next to the responsibility on the index card
is the collaborator sensor. The token is then passed to the sensor object. 
4. When the token is passed, the holder of the class card is asked to describe

5.

the responsibilities noted on the card. The group determines whether one (or
more) of the responsibilities satisﬁes the use-case requirement.
If the responsibilities and collaborations noted on the index cards cannot
accommodate the use-case, modiﬁcations are made to the cards. This may
include the deﬁnition of new classes (and corresponding CRC index cards) or
the speciﬁcation of new or revised responsibilities or collaborations on exist-
ing cards.

This modus operandi continues until the use-case is ﬁnished. When all use-cases (or
use-case diagrams) have been reviewed, OOA continues.

21.4.3 Deﬁning Structures and Hierarchies
Once classes and objects have been identiﬁed using the CRC model, the analyst begins
to focus on the structure of the class model and the resultant hierarchies that arise as
classes and subclasses emerge. Using UML notation, a variety of class diagrams can be
created. Generalization/specialization class structures can be created for identiﬁed classes.
To illustrate, consider the sensor object deﬁned for SafeHome, shown in Figure
21.4. Here, the generalization class, sensor, is reﬁned into a set of specializations—

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

589

FIGURE 21.4
Class diagram
for 
generalization/
specialization

Sensor

Attributes

Operations

Entry sensor

Smoke sensor

Motion sensor

entry sensor, smoke sensor, and motion sensor. The attributes and operations
noted for the sensor class are inherited by the specializations of the class. We have
created a simple class hierarchy.  

In other cases, an object represented in the initial model might actually be com-
posed of a number of component parts that could themselves be deﬁned as objects.
These aggregate objects can be represented as a composite aggregate [ERI98] and are
deﬁned using the notation represented in Figure 21.5. The diamond implies an assem-
bly relationship. It should be noted that the connecting lines may be augmented with
additional symbols (not shown) to represent cardinality. These are adapted from the
entity/relationship modeling notation discussed in Chapter 12.

Control panel

Keypad

Screen

Lite

FIGURE 21.5
Class diagram
for composite
aggregates

590

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

A subsystem (UML
package) points to a
more-detailed class
hierarchy.

Structure representations provide the analyst with a means for partitioning the
CRC model and representing that partitioning graphically. The expansion of each class
provides needed detail for review and for subsequent design.

21.4.4 Deﬁning Subjects and Subsystems
An analysis model for a complex application may have hundreds of classes and dozens
of structures. For this reason, it is necessary to deﬁne a concise representation that
is a digest of the CRC and structure models just described.

When a group of all classes collaborate among themselves to accomplish a set of
cohesive responsibilities, they are often referred to as subsystems or packages (in UML
terminology). Subsystems or packages are abstractions that provide a reference or
pointer to more detail in the analysis model. When viewed from the outside, a sub-
system can be treated as a black box that contains a set of responsibilities and that
has its own (outside) collaborators. A subsystem implements one or more contracts
[WIR90] with its outside collaborators. A contract is a speciﬁc list of requests that col-
laborators can make of the subsystem.8

Subsystems can be represented with the context of CRC modeling by creating a
subsystem index card. The subsystem index card indicates the name of the subsys-
tem, the contracts that the subsystem must accommodate, and the classes or (other)
subsystems that support the contract. 

Packages are identical to subsystems in intent and content but are represented
graphically in UML. For example, assume that the control panel for SafeHome is con-
siderably more complex that the one implied by Figure 21.5, containing multiple dis-
play areas, a sophisticated key arrangement, and other features. It might be modeled
as the composite aggregate structure shown in Figure 21.6. If the overall require-
ments model contains dozens of these structures (SafeHome would not), it would be
difﬁcult to absorb the entire representation at one time. By deﬁning a package refer-
ence as shown in the ﬁgure, the entire structure can be referenced by a single icon
(the ﬁle folder). Package references can be created for any structure that has multi-
ple objects.

At the most abstract level, the OOA model would contain only package references
such as those illustrated at the top of Figure 21.7. Each of the references would be
expanded into a structure. Structures for the control panel and sensor objects (Fig-
ures 21.5 and 21.6) are shown in the ﬁgure; structures for system, sensor event
and audible alarm would also be created.

The dashed arrows shown at the top of Figure 21.7 represent dependence rela-
tionships between the packages shown. For example, sensor depends on the status
of the sensor event package. The solid arrows represent composition. In the exam-
ple shown, the system package is composed of the control panel, sensor, and
audible alarm packages. 

8 Recall that classes interact using a client/server philosophy. In this case, the subsystem is the

server and outside collaborators are clients.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

591

FIGURE 21.6
Package 
(subsystem)
reference

6. Control panel

Control panel

Subsystem
(package)
reference

Keys

Display area

Lite

Keypad

FKs

LCD display

Graphics

Messages

21.5 THE OBJECT-RELATIONSHIP MODEL

The CRC modeling approach establishes the ﬁrst elements of class and object rela-
tionships. The ﬁrst step in establishing relationships is to understand the responsi-
bilities for each class. The CRC model index card contains a list of responsibilities.
The next step is to deﬁne those collaborator classes that help in achieving each respon-
sibility. This establishes the “connection” between classes. 

A relationship exists between any two classes that are connected.9 Therefore, col-
laborators are always related in some way. The most common type of relationship is
binary—a connection exists between two classes. When considered within the con-
text of an OO system, a binary relationship has a speciﬁc direction10 that is deﬁned
based on which class plays the role of the client and which acts as a server.

9 Other terms for relationship are association [RUM91] and connection [COA91].
10 It is important to note that this is a departure from the bidirectional nature of relationships used

in data modeling (Chapter 12).

592

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

SafeHome

6. Control panel

2. System

3. Sensor event

5. Audible alarm

4. Sensor

Control panel

Sensor

Keys

Display area

Lite

Entry sensor

Smoke sensor

Motion sensor

Keypad

FKs

LCD display

Graphics

Messages

FIGURE 21.7 An analysis model with package references

Rumbaugh and his colleagues [RUM91] suggest that relationships can be derived
by examining the stative verbs or verb phrases in the statement of scope or use-cases
for the system. Using a grammatical parse, the analyst isolates verbs that indicate
physical location or placement (next to, part of, contained in), communications (trans-
mits to, acquires from), ownership (incorporated by, is composed of), and satisfac-
tion of a condition (manages, coordinates, controls). These provide an indication of
a relationship.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

593

FIGURE 21.8
Relationships
between
objects

System

Contains

1:1

1:1

Control panel

Polls

1:1

1:m

Sensor

?

How is an
object-

relationship model
derived?

Produces

1:1

0:k

Audible
alarm

Recognizes

1:1 

0:n 

Sensor
event

The Uniﬁed Modeling Language notation for the object-relationship model makes
use of a symbology that has been adapted from the entity-relationship modeling tech-
niques discussed in Chapter 12. In essence, objects are connected to other objects
using named relationships. The cardinality of the connection (see Chapter 12) is spec-
iﬁed and an overall network of relationships is established.

The object relationship model (like the entity relationship model) can be derived

in three steps:

1. Using the CRC index cards, a network of collaborator objects can be

drawn. Figure 21.8 represents the class connections for SafeHome objects.
First the objects are drawn, connected by unlabeled lines (not shown in the
ﬁgure) that indicate some relationship exists between the connected objects. 
2. Reviewing the CRC model index card, responsibilities and collabora-

tors are evaluated and each unlabeled connected line is named. To
avoid ambiguity, an arrow head indicates the “direction” of the relationship
(Figure 21.8). 

3. Once the named relationships have been established, each end is

evaluated to determine cardinality (Figure 21.8). Four options exist: 0 to
1, 1 to 1, 0 to many, or 1 to many. For example, the SafeHome system con-
tains a single control panel (the 1:1 cardinality notation indicates this). At
least one sensor must be present for polling by the control panel. However,
there may be many sensors present (the 1:m notation indicates this). One
sensor can recognize from 0 to many sensor events (e.g., smoke is detected
or a break-in has occurred). 

The steps just noted continue until a complete object-relationship model has been
produced. 

594

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

By developing an object-relationship model, the analyst adds still another dimen-
sion to the overall analysis model. Not only are the relationships between objects
identiﬁed, but all important message paths are deﬁned (Chapter 20). In our discus-
sion of Figure 21.7, we made reference to the arrows that connected package sym-
bols. These are also message paths. Each arrow implies the interchange of messages
among subsystems in the model.

21.6 THE OBJECT-BEHAVIOR MODEL

?

What are 
the steps

required to build
an object-behavior
model?

The CRC model and the object-relationship model represent static elements of the
OO analysis model. It is now time to make a transition to the dynamic behavior of
the OO system or product. To accomplish this, we must represent the behavior of the
system as a function of speciﬁc events and time.

The object-behavior model indicates how an OO system will respond to external
events or stimuli. To create the model, the analyst must perform the following steps:

1. Evaluate all use-cases (Section 21.4.1) to fully understand the sequence of

2.

interaction within the system.
Identify events that drive the interaction sequence and understand how these
events relate to speciﬁc objects.

3. Create an event trace [RUM91] for each use-case.
4. Build a state transition diagram for the system.
5. Review the object-behavior model to verify accuracy and consistency.

Each of these steps is discussed in the sections that follow.

21.6.1 Event Identiﬁcation with Use-Cases
As we noted in Section 21.4.1, the use-case represents a sequence of activities that
involves actors and the system. In general, an event occurs whenever an OO system
and an actor (recall that an actor can be a person, a device, or even an external sys-
tem) exchange information. Recalling the discussion presented in Chapter 12, it is
important to note that an event is Boolean. That is, an event is not the information
that has been exchanged but rather the fact that information has been exchanged. 
A use-case is examined for points of information exchange. To illustrate, recon-

sider the use-case for SafeHome described in Section 11.2.4:

1. The homeowner observes the SafeHome control panel (Figure 11.2) to determine if the
system is ready for input. If the system is not ready, the homeowner must physically close
windows/doors so that the ready indicator is present. [A not-ready indicator implies that a
sensor is open, i.e., that a door or window is open.]
2. The homeowner uses the keypad to key in a four-digit password. The password is com-
pared with the valid password stored in the system. If the password is incorrect, the con-

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

595

trol panel will beep once and reset itself for additional input. If the password is correct, the
control panel awaits further action.
3. The homeowner selects and keys in stay or away to activate the system. Stay activates
only perimeter sensors (inside motion detecting sensors are deactivated). Away activates
all sensors.
4. When activation occurs, a red alarm light can be observed by the homeowner.

The underlined portions of the use-case scenario indicate events. An actor should be
identiﬁed for each event; the information that is exchanged should be noted; and any
conditions or constraints should be listed.

As an example of a typical event, consider the underlined use-case phrase “home-
owner uses the keypad to key in a four-digit password.” In the context of the OO
analysis model, the object, homeowner, transmits an event to the object control
panel. The event might be called password entered. The information transferred is
the four digits that constitute the password, but this is not an essential part of the
behavioral model. It is important to note that some events have an explicit impact
on the ﬂow of control of the use-case, while others have no direct impact on the ﬂow
of control. For example, the event password entered does not explicitly change the
ﬂow of control of the use-case, but the results of the event compare password (derived
from the interaction “password is compared with the valid password stored in the
system”) will have an explicit impact on the information and control ﬂow of the Safe-
Home software.

Once all events have been identiﬁed, they are allocated to the objects involved.
Objects can be responsible for generating events (e.g., homeowner generates the
password entered event) or recognizing events that have occurred elsewhere (e.g.,
control panel recognizes the binary result of the compare password event).

21.6.2 State Representations
In the context of OO systems, two different characterizations of states must be con-
sidered: (1) the state of each object as the system performs its function and (2) the
state of the system as observed from the outside as the system performs its function.
The state of an object takes on both passive and active characteristics [CHA93]. A
passive state is simply the current status of all of an object’s attributes. For example,
the passive state of the aggregate object player (in the video game application dis-
cussed earlier) would include the current position and orientation attributes of player
as well as other features of player that are relevant to the game (e.g., an attribute that
indicates magic wishes remaining). The active state of an object indicates the current sta-
tus of the object as it undergoes a continuing transformation or processing. The object
player might have the following active states: moving, at rest, injured, being cured;
trapped, lost, and so forth. An event (sometimes called a trigger) must occur to force
an object to make a transition from one active state to another. One component of

As you begin to
identify states, focus
on externally
observable modes of
behavior. Later, you
may reﬁne these
states into behaviors
that are not evident
from outside the
system.

596

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 21.9
A 
representation
of active state
transitions

Compare password = incorrect

Control
panel

Control
panel

Control
panel

Password entered

 

"Re-enter"

Compare password = incorrect
Compare password = correct

"At rest"

"Comparing"

Control
panel

Activation successful

"Selecting"

an object-behavior model is a simple representation of the active states for each
object and the events (triggers) that cause changes between these active states. Fig-
ure 21.9 illustrates a simple representation of active states for the control panel
object in the SafeHome system.

Each arrow shown in Figure 21.9 represents a transition from one active state of
an object to another. The labels shown for each arrow represent the event that trig-
gers the transition. Although the active state model provides useful insight into the
“life history” of an object, it is possible to specify additional information to provide
more depth in understanding the behavior of an object. In addition to specifying the
event that causes the transition to occur, the analyst can specify a guard and an action
[CHA93]. A guard is a Boolean condition that must be satisﬁed in order for the tran-
sition to occur. For example, the guard for the transition from the “at rest” state to
the “comparing state” in Figure 21.9 can be determined by examining the use-case:

if (password input = 4 digits) then make transition to comparing state;

In general, the guard for a transition usually depends upon the value of one or more
attributes of an object. In other words, the guard depends on the passive state of the
object.

An action occurs concurrently with the state transition or as a consequence of it
and generally involves one or more operations (responsibilities) of the object. For
example, the action connected to the password entered event (Figure 21.9) is an oper-
ation that accesses a password object and performs a digit-by-digit comparison to
validate the entered password.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

FIGURE 21.10
A partial event
trace for Safe-
Home

Homeowner

System ready

Enters password

Control panel

597

System

Initiates beep
Beep sounded

Ready for activation/deactivation

Selects stay/away

Ready for next action

Activate/deactivate sensors
Sensors activated/deactivated

Red light on request

Red light on

A transition from one
state to another
requires that an event
occur. Events are
Boolean in nature and
often occur when
objects communicate
with one another.

The second type of behavioral representation for OOA considers a state repre-
sentation for the overall product or system. This representation encompasses a sim-
ple event trace model [RUM91] that indicates how events cause transitions from object
to object and a state transition diagram that depicts the processing behavior of each
object.

Once events have been identiﬁed for a use-case, the analyst creates a represen-
tation of how events cause ﬂow from one object to another. Called an event trace, this
representation is a shorthand version of the use-case. It represents key objects and
the events that cause behavior to ﬂow from object to object.

Figure 21.10 illustrates a partial event trace for the SafeHome system. Each of the
arrows represents an event (derived from a use-case) and indicates how the event
channels behavior between SafeHome objects. The ﬁrst event, system ready, is derived
from the external environment and channels behavior to the homeowner object.
The homeowner enters a password. The event initiates beep and “beep sounded” and
indicates how behavior is channeled if the password is invalid. A valid password
results in flow back to homeowner. The remaining events and traces follow the
behavior as the system is activated or deactivated.

Once a complete event trace has been developed, all of the events that cause tran-
sitions between system objects can be collated into a set of input events and output
events (from an object). This can be represented using an event ﬂow diagram [RUM91].
All events that ﬂow into and out of an object are noted as shown in Figure 21.11. A
state transition diagram (Chapter 12) can then be developed to represent the behav-
ior associated with responsibilities for each class.

598

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

System
ready

Homeowner

Selects stay/away
Enters password

Control
panel

Ready for next action

Ready for activation/deactivation

Beep sounded
Sensors activated/deactivated
Red light on

Initiates beep
Activate/deactivate sensors
Red light on request

System

FIGURE 21.11 A partial event ﬂow diagram for SafeHome

UML uses a combination of state diagrams, sequence diagrams, collaboration dia-
grams, and activity diagrams to represent the dynamic behavior of the objects and
classes that have been identiﬁed as part of the analysis model. A complete discus-
sion of these graphical representations and the language descriptions that underlie
them is beyond the scope of this book. The interested reader should see [BOO99],
[BEN99], [ALH98], and [ERI98] for additional detail.

21.7 SUMMARY

Object-oriented analysis methods enable a software engineer to model a problem by
representing both static and dynamic characteristics of classes and their relation-
ships as the primary modeling components. Like earlier OO analysis methods, the
Uniﬁed Modeling Language builds an analysis model that has the following charac-
teristics: (1) representation of classes and class hierarchies, (2) creation of object-
relationship models, and (3) derivation of object-behavior models. 

Analysis for object-oriented systems occurs at many different levels of abstrac-
tion. At the business or enterprise level, the techniques associated with OOA can be
coupled with a business process engineering approach. This technique is often called
domain analysis. At an application level, the object model focuses on speciﬁc cus-
tomer requirements as those requirements affect the application to be built.

The OOA process begins with the deﬁnition of use-cases—scenarios that describe
how the OO system is to be used. The class-responsibility-collaborator modeling tech-
nique is then applied to document classes and their attributes and operations. It also
provides an initial view of the collaborations that occur among objects. The next step
in the OOA process is classiﬁcation of objects and the creation of a class hierarchy.
Subsystems (packages) can be used to encapsulate related objects. The object-
relationship model provides an indication of how classes are connected to one another,
and the object-behavior model indicates the behavior of individual objects and the
overall behavior of the OO system.

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

599

REFERENCES

[ALH98] Alhir, S.S., UML in a Nutshell, O’Reilly & Associates, 1998.
[AMB95] Ambler, S., “Using Use-Cases,” Software Development, July 1995, pp. 53–61.
[ARA89] Arango, G. and R. Prieto-Diaz, “Domain Analysis: Concepts and Research
Directions,” Domain Analysis: Acquisition of Reusable Information for Software Con-
struction, (Arango, G. and R. Prieto-Diaz, eds.), IEEE Computer Society Press, 1989. 
[BEN99] Bennett, S., S. McRobb, and R. Farmer, Object Oriented System Analysis and
Design Using UML, McGraw-Hill, 1999.
[BER93] Berard, E.V., Essays on Object-Oriented Software Engineering, Addison-
Wesley, 1993.
[BOO94] Booch, G., Object-Oriented Analysis and Design, 2nd ed., Benjamin Cum-
mings, 1994.
[BOO99] Booch, G., I. Jacobson, J. Rumbaugh, The Uniﬁed Modeling Language User
Guide, Addison-Wesley, 1999.
[CAR98] Carmichael, A., Developing Business Objects, SIGS Books, 1998).
[CHA93] De Champeaux, D., D. Lea, and P. Faure, Object-Oriented System Develop-
ment, Addison-Wesley, 1993. 
[COA91] Coad, P. and E. Yourdon, Object-Oriented Analysis, 2nd ed., Prentice-Hall,
1991.
[EEL98] Eeles, P. and O. Sims, Building Business Objects, Wiley, 1998. 
[ERI98] Eriksson, H.E. and M. Penker, UML Toolkit, Wiley, 1998.
[FIC92]
Fichman, R.G. and C.F. Kemerer, “Object-Oriented and Conventional Analy-
sis and Design Methodologies,” Computer, vol. 25, no. 10, October 1992, pp. 22–39. 
Fingar, P., The Blueprint for Business Objects, Cambridge University Press,
[FIN96]
1996.
[FIR93]
Wiley, 1993.
[GRA94] Graham, I., Object-Oriented Methods, Addison-Wesley, 1994.
[JAC92]
[JAC99]
Addison-Wesley, 1999. 
[MAT94] Mattison, R., The Object-Oriented Enterprise, McGraw-Hill, 1994.
[MON92] Monarchi, D.E. and G.I. Puhr, “A Research Typology for Object-Oriented
Analysis and Design,” CACM, vol. 35, no. 9, September 1992, pp. 35–47.
[RUM91] Rumbaugh, J., et al., Object-Oriented Modeling and Design, Prentice-Hall,
1991.
[RUM99] Rumbaugh, J., I. Jacobson, and G. Booch, The Unified Modeling Language
Reference Manual, Addison-Wesley, 1999. 
[SUL94] Sullo, G.C., Object Engineering, Wiley, 1994.
[TAY95] Taylor, D.A., Business Engineering with Object Technology, Wiley, 1995.
[WIR90] Wirfs-Brock, R., B. Wilkerson, and L. Weiner, Designing Object-Oriented Soft-
ware, Prentice-Hall, 1990.

Jacobson, I., Object-Oriented Software Engineering, Addison-Wesley, 1992.
Jacobson, I., G. Booch, J. Rumbaugh, Uniﬁed Software Development Process,

Firesmith, D.G., Object-Oriented Requirements Analysis and Logical Design,

600

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

PROBLEMS AND POINTS TO PONDER

21.1. Obtain one or more books dedicated to the Uniﬁed Modeling Language and
compare it to structured analysis (Chapter 12) using the modeling dimensions pro-
posed by Fichman and Kemerer [FIC92] in Section 21.1.1.

21.2. Develop a classroom presentation on one static or dynamic modeling diagram
used in UML. Present the diagram in the context of a simple example, but provide
enough detail to demonstrate most important aspects of the diagrammatic form.

21.3. Conduct an abbreviated domain analysis for one of the following areas:

a. A university student record-keeping system.
b. An e-commerce application (e.g., clothes, books, electronic gear).
c. Customer service for a bank.
d. A video game developer.
e. An application area suggested by your instructor.

Be sure to isolate classes that can be used for a number of applications in the domain.

21.4. In your own words describe the difference between static and dynamic views
of an OO system.

21.5. Write a use-case for the SafeHome system discussed in this book. The use-
case should address the scenario required to deﬁne a security zone. A security zone
encompasses a set of sensors can be addressed, activated, and deactivated as a set
rather than individually. As many as ten security zones can be deﬁned. Be creative
here but stay within the bounds of the SafeHome control panel as it is deﬁned earlier
in the book.

21.6. Develop a set of use-cases for the PHTRS system introduced in Problem 12.13.
You’ll have to make a number of assumptions about the manner in which a user inter-
acts with this system.

21.7. Develop a set of use-cases for any one of the following applications:

a. Software for a general-purpose personal digital assistant.
b. Software for a video game of your choosing.
c. Software that sits inside a climate control system for a car.
d. Software for a navigation system for a car.
e. A system (product) suggested by your instructor.

Do a few hours of research on the application area and conduct a FAST meeting
(Chapter 11) with your fellow students to develop basic requirements (your instruc-
tor will help you coordinate this).

CHAPTER 21 OBJECT-ORIENTED ANALYSIS

601

21.8. Develop a complete set of CRC model index cards on the product or system
you chose as part of Problem 21.7.

21.9. Conduct a review of the CRC index cards with your colleagues. How many
additional classes, responsibilities, and collaborators were added as a consequence
of the review?

21.10. Develop a class hierarchy for the product or system you chose as part of Prob-
lem 21.7.

21.11. Develop a set of subsystems (packages) for the product or system you chose
as part of Problem 21.7.

21.12. Develop an object-relationship model for the product or system you chose
as part of Problem 21.7.

21.13. Develop an object-behavior model for the product or system you chose as
part of Problem 21.7. Be sure to list all events, provide an event trace, develop an
event ﬂow diagram, and deﬁne state diagram for each class.

21.14. In your own words, describe how collaborators for a class are determined.

21.15. What strategy would you propose for deﬁning subsystems for a collection of
classes?

21.16 What role does cardinality play in the development of an object-relationship
model?

21.17. What is the difference between an active and a passive state for an object?

FURTHER READINGS AND INFORMATION SOURCES

Use-cases form the foundation of object-oriented analysis, regardless of the OOA
method that is chosen.  Books by Rosenberg and Scott (Use Case Driven Object Mod-
eling with UML: A Practical Approach, Addison-Wesley, 1999); Schneider, Winters, and
Jacobson (Applying Use Cases: A Practical Guide, Addison-Wesley, 1998); and Texel
and Williams (Use Cases Combined With Booch/OMT/UML: Process and Products, 
Prentice-Hall, 1997) provide worthwhile guidance in the creation and use of this
important requirements elicitation and representation mechanism.

Virtually every recent book published on object-oriented analysis and design empha-
sizes UML. Those serious about applying UML in their work should acquire [BOO99],
[RUM99], and [JAC99]. In addition, the following books are representative of dozens
written on UML technology:

Douglass, B., Real-Time UML: Developing Efficient Objects for Embedded Systems, Addison-

Wesley, 1999. 

602

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Fowler, M. and K. Scott, UML Distilled, 2nd ed., Addison-Wesley, 2000.

Odell, J.J. and M. Fowler, Advanced Object-Oriented Analysis and Design Using UML, SIGS Books,

1998.

Oestereich, B., Developing Software with UML: Object-Oriented Analysis and Design in Practice,

Addison-Wesley, 1999. 

A wide variety of information sources on object-oriented analysis and related sub-
jects is available on the Internet. An up-to-date list of World Wide Web references
that are relevant to OOA can be found at the SEPA Web site:
http://www.mhhe.com/engcs/compsci/pressman/resources/OOA.mhtml 

C H A P T E R

22 OBJECT-ORIENTED DESIGN

K E Y
C O N C E P T S
component-level
design   . . . . . . . . 621
design
components . . . . 614
design criteria . . 607
design patterns . 624
layers . . . . . . . . . 604
object design . . . 618
OOD methods. . . 608
OOD pyramid . . . 605
OO programming 625
operations . . . . . 619
subsystem
design . . . . . . . . . 612
system design . . 611
UML. . . . . . . . . . . 610

Object-oriented design transforms the analysis model created using

object-oriented analysis (Chapter 21) into a design model that serves
as a blueprint for software construction. Yet, the job of the software
designer can be daunting. Gamma and his colleagues [GAM95] provide a rea-
sonably accurate picture of OOD when they state:

Designing object-oriented software is hard, and designing reusable object-oriented
software is even harder. You must ﬁnd pertinent objects, factor them into classes at
the right granularity, deﬁne class interfaces and inheritance hierarchies, and estab-
lish key relationships among them. Your design should be speciﬁc to the problem at
hand but also general enough to address future problems and requirements. You also
want to avoid redesign, or at least minimize it. Experienced object-oriented design-
ers will tell you that a reusable and ﬂexible design is difﬁcult if not impossible to get
"right" the ﬁrst time. Before a design is ﬁnished, they usually try to reuse it several
times, modifying it each time.

Unlike conventional software design methods, OOD results in a design that
achieves a number of different levels of modularity. Major system components
are organized into subsystems, a system-level “module.” Data and the opera-
tions that manipulate the data are encapsulated into objects—a modular form

Q U I C K
L O O K

What is it? The design of object-
oriented software requires the def-
inition of a multilayered software
architecture, the speciﬁcation of subsystems that
perform required functions and provide infra-
structure support, a description of objects (classes)
that form the building blocks of the system, and
a description of the communication mechanisms
that allow data to flow between layers, subsys-
tems, and objects. Object-oriented design accom-
plishes all of these things.

Who  does  it? OOD  is  performed  by  a  software 

engineer.

Why is it important? An object-oriented system draws
upon class definitions that are derived from the
analysis model. Some of these deﬁnitions will have

to be built from scratch, but many others may be
reused if appropriate design patterns are recog-
nized. OOD establishes a design blueprint that
enables a software engineer to define the OO
architecture in a manner that maximizes reuse,
thereby improving development speed and end-
product quality. 

What are the steps? OOD is divided into two major
activities: system design and object design. Sys-
tem design creates the product architecture, deﬁn-
ing a series of “layers” that accomplish specific
system functions and identifying the classes that
are encapsulated by subsystems that reside at
each layer. In addition, system design considers
the specification of three components: the user
interface, data management functions, and task

603

604

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Q U I C K
L O O K

management  facilities.  Object
design  focuses  on  the  internal
detail of individual classes, deﬁn-

ing attributes, operations, and message detail.

What is the work product? An OO design model
encompasses software architecture, user interface
description, data management components, task

management facilities, and detailed descriptions
of each class to be used in the system.

How do I ensure that I’ve done it right? At each stage,
the elements of the object-oriented design model
are reviewed for clarity, correctness, complete-
ness, and consistency with customer requirements
and with one another.

that is the building block of an OO system. In addition, OOD must describe the spe-
ciﬁc data organization of attributes and the procedural detail of each individual oper-
ation.  These  represent  data  and  algorithmic  pieces  of  an  OO  system  and  are
contributors to overall modularity.

The unique nature of object-oriented design lies in its ability to build upon four
important software design concepts: abstraction, information hiding, functional inde-
pendence, and modularity (Chapter 13). All design methods strive for software that
exhibits these fundamental characteristics, but only OOD provides a mechanism that
enables the designer to achieve all four without complexity or compromise.

Object-oriented design, object-oriented programming, and object-oriented test-
ing are construction activities for OO systems. In this chapter, we consider the ﬁrst
step in construction.

22.1 DESIGN FOR OBJECT-ORIENTED SYSTEMS

In Chapter 13, we introduced the concept of a design pyramid for conventional soft-
ware. Four design layers—data, architectural, interface, and component level—were
deﬁned and discussed. For object-oriented systems, we can also deﬁne a design pyra-
mid, but the layers are a bit different. Referring to Figure 22.1, the four layers of the
OO design pyramid are

“In design, we shape
the system and ﬁnd
its form . . .”
Ivar Jacobson,
Grady Booch, and
James Rumbaugh 

The subsystem layer contains a representation of each of the subsystems
that enable the software to achieve its customer-deﬁned requirements and to
implement the technical infrastructure that supports customer requirements.
The class and object layer contains the class hierarchies that enable the
system to be created using generalizations and increasingly more targeted
specializations. This layer also contains representations of each object.
The message layer contains the design details that enable each object to
communicate with its collaborators. This layer establishes the external and
internal interfaces for the system.
The responsibilities layer contains the data structure and algorithmic
design for all attributes and operations for each object.

CHAPTER 22 OBJECT-ORIENTED DESIGN

605

FIGURE 22.1
The OO design
pyramid

Responsibilities

design

Message
design

Class and object

design

Subsystem

design

The design pyramid focuses exclusively on the design of a speciﬁc product or sys-
tem. It should be noted, however, that another “layer” of design exists, and this layer
forms the foundation on which the pyramid rests. The foundation layer focuses on
the design of domain objects (called design patterns later in this chapter). Domain
objects play a key role in building the infrastructure for the OO system by providing
support for human/computer interface activities, task management, and data man-
agement. Domain objects can also be used to ﬂesh out the design of the application
itself.

22.1.1 Conventional vs. OO Approaches
Conventional approaches to software design apply a distinct notation and set of
heuristics to map the analysis model into a design model. Recalling Figure 13.1, each
element of the conventional analysis model maps into one or more layers of the
design model. Like conventional software design, OOD applies data design when
attributes are represented, interface design when a messaging model is developed,
and component-level (procedural) design for the design of operations. It is important
to note that the architecture of an OO design has more to do with the collaborations
among objects than with the ﬂow of control between components of the system.

Although similarity between the conventional and OO design models does exist,
we have chosen to rename the layers of the design pyramid to reﬂect more accurately
the nature of an OO design. Figure 22.2 illustrates the relationship between the OO
analysis model (Chapter 21) and design model that will be derived from it.1

1 It is important to note that the derivation is not always straightforward. For further discussion,

see [DAV95].

606

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Attributes, o p

CRC
index
cards

e r a ti o n s , collaborators

Responsibilities

design

Object-

relationship

model

Use cases

Object-behavior

model

Message
design

Class and object

design

Subsystem

design

The analysis model

The design model

FIGURE 22.2 Translating an OOA model into an OOD model

?

What 
criteria can

be used to
compare
conventional and
OOD methods?

The subsystem design is derived by considering overall customer requirements
(represented with use-cases) and the events and states that are externally observ-
able (the object-behavior model). Class and object design is mapped from the descrip-
tion of attributes, operations, and collaborations contained in the CRC model. Message
design is driven by the object-relationship model, and responsibilities design is derived
using the attributes, operations, and collaborations described in the CRC model.

Fichman and Kemerer [FIC92] suggest ten design modeling components that may

be used to compare various conventional and object-oriented design methods:

1. Representation of hierarchy of modules.
2. Speciﬁcation of data deﬁnitions.
3. Speciﬁcation of procedural logic.
4.
Indication of end-to-end processing sequences.
5. Representation of object states and transitions.
6. Deﬁnition of classes and hierarchies.
7. Assignment of operations to classes.
8. Detailed deﬁnition of operations.
9. Speciﬁcation of message connections.

10.

Identiﬁcation of exclusive services.

WebRef
A discussion that
addresses the question
“What makes a good
object-oriented design?”
can be found at 
www.kinetica.com/
ootips/ood-
principles.html

?

What basic
principles
guide us in the
design of modular
architectures?

CHAPTER 22 OBJECT-ORIENTED DESIGN

607

Because many conventional and object-oriented design approaches are available, it
is difﬁcult to develop a generalized comparison between the two methods. It can be
stated, however, that modeling dimensions 5 through 10 are not supported using
structured design (Chapter 14) or its derivatives.

22.1.2 Design Issues
Bertrand Meyer [MEY90] suggests ﬁve criteria for judging a design method's ability
to achieve modularity and relates these to object-oriented design:

• Decomposability—the facility with which a design method helps the designer

to decompose a large problem into subproblems that are easier to solve.

• Composability—the degree to which a design method ensures that program

components (modules), once designed and built, can be reused to create
other systems.

• Understandability—the ease with which a program component can be under-

stood without reference to other information or other modules.

• Continuity—the ability to make small changes in a program and have these
changes manifest themselves with corresponding changes in just one or a
very few modules.

• Protection—an architectural characteristic that will reduce the propagation of

side effects if an error does occur in a given module.

From these criteria, Meyer [MEY90] suggests ﬁve basic design principles that can be
derived for modular architectures: (1) linguistic modular units, (2) few interfaces, (3)
small  interfaces  (weak  coupling),  (4)  explicit  interfaces,  and  (5)  information 
hiding. 

Modules are deﬁned as linguistic modular units when they "correspond to syntac-
tic units in the language used" [MEY90]. That is, the programming language to be
used should be capable of supporting the modularity deﬁned directly. For example, if
the designer creates a subroutine, any of the older programming languages (e.g.,
FORTRAN, C, Pascal) could implement it as a syntactic unit. But if a package that con-
tains data structures and procedures and identiﬁes them as a single unit were deﬁned,
a language such as Ada (or another object-oriented language) would be necessary
to directly represent this type of component in the language syntax.

To achieve low coupling (a design concept introduced in Chapter 13), the num-
ber of interfaces between modules should be minimized ("few interfaces") and the
amount of information that moves across an interface should be minimized ("small
interfaces"). Whenever components do communicate, they should do so in an obvi-
ous and direct way ("explicit interfaces"). For example, if component X and compo-
nent Y communicate through a global data area (what we called common coupling
in Chapter 13), they violate the principle of explicit interfaces because the commu-
nication between the components is not obvious to an outside observer. Finally, we

608

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

achieve the principle of information hiding when all information about a component
is hidden from outside access, unless that information is speciﬁcally deﬁned as pub-
lic information.

The design criteria and principles presented in this section can be applied to any
design method (e.g., we can apply them to structured design). As we will see, how-
ever, the object-oriented design method achieves each of the criteria more efﬁciently
than other approaches and results in modular architectures that allow us to meet
each of the modularity criteria most effectively.

22.1.3 The OOD Landscape
As we noted in Chapter 21, a wide variety of object-oriented analysis and design
methods were proposed and used during the 1980s and 1990s. These methods estab-
lished the foundation for modern OOD notation, design heuristics, and models. A
brief overview of the most important early OOD methods follows:

The Booch method. As we noted in Chapter 21, the Booch method
[BOO94] encompasses both a “micro development process” and a “macro
development process.” In the design context, macro development encom-
passes an architectural planning activity that clusters similar objects in sepa-
rate architectural partitions, layers objects by level of abstraction, identiﬁes
relevant scenarios, creates a design prototype, and validates the design pro-
totype by applying it to usage scenarios. Micro development deﬁnes a set of
“rules” that govern the use of operations and attributes and the domain-spe-
ciﬁc policies for memory management, error handling, and other infrastruc-
ture functions; develops scenarios that describe the semantics of the rules
and policies; creates a prototype for each policy; instruments and reﬁnes the
prototype; and reviews each policy so that it “broadcasts its architectural
vision” [BOO94].
The Rumbaugh method. The object modeling technique [RUM91] encom-
passes a design activity that encourages design to be conducted at two differ-
ent levels of abstraction. System design focuses on the layout for the
components that are needed to construct a complete product or system. The
analysis model is partitioned into subsystems, which are then allocated  to
processors and tasks. A strategy for implementing data management is
deﬁned and global resources and the control mechanisms required to access
them are identiﬁed.

Object design emphasizes the detailed layout of an individual object. Oper-

ations are selected from the analysis model and algorithms are deﬁned for
each operation. Data structures that are appropriate for attributes and algo-
rithms are represented. Classes and class attributes are designed in a manner
that optimizes access to data and improves computational efﬁciency. A mes-
saging model is created to implement the object relationships (associations).

“There is no reason
why the transition
from requirements to
design should be
any easier in
software engineering
than it is in any
other engineering
discipline. Design is
hard.”
Alan Davis 

CHAPTER 22 OBJECT-ORIENTED DESIGN

609

The Jacobson method. The design activity for OOSE (object-oriented soft-
ware engineering) [JAC92] is a simpliﬁed version of the proprietary objectory
method, also developed by Jacobson. The design model emphasizes trace-
ability to the OOSE analysis model. First, the idealized analysis model is
adapted to ﬁt the real world environment. Then primary design objects,
called blocks,2 are created and categorized as interface blocks, entity blocks,
and control blocks. Communication between blocks during execution is
deﬁned and the blocks are organized into subsystems.
The Coad and Yourdon method. The Coad and Yourdon method for OOD
[COA91] was developed by studying how “effective object-oriented design-
ers” do their design work. The design approach addresses not only the appli-
cation but also the infrastructure for the application and focuses on the
representation of four major system components: the problem domain com-
ponent, the human interaction component, the task management compo-
nent, and the data management component.
The Wirfs-Brock method. Wirfs-Brock, Wilkerson, and Weiner [WIR90]
deﬁne a continuum of technical tasks in which analysis leads seamlessly into
design. Protocols3 for each class are constructed by reﬁning contracts
between objects. Each operation (responsibility) and protocol (interface
design) is designed at a level of detail that will guide implementation. Speciﬁ-
cations for each class (deﬁning private responsibilities and detail for opera-
tions) and each subsystem (identifying all encapsulated classes and the
interaction between subsystems) are developed. 

Although the terminology and process steps for each of these OOD methods dif-
fer, the overall OOD processes are reasonably consistent. To perform object-oriented
design, a software engineer should perform the following generic steps: 

1. Describe each subsystem and allocate it to processors and tasks.
2. Choose a design strategy for implementing data management, interface sup-

port, and task management.

3. Design an appropriate control mechanism for the system.
4. Perform object design by creating a procedural representation for each oper-

ation and data structures for class attributes.

5. Perform message design using collaborations between objects and object

relationships. 

6. Create the messaging model.
7. Review the design model and iterate as required.

2 A block is the design abstraction that allows for the representation of an aggregate object.
3 A protocol is a formal description of the messages to which a class will respond.

Although it is not
nearly as robust as
UML, the Wirfs-Brock
method has a simple
elegance that makes it
an interesting
alternative approach to
OOD.

A set of generic steps
are applied during
OOD, regardless of the
design method that is
chosen.

610

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

WebRef
An extensive tutorial and
listing of UML resources
including tools, papers,
and examples can be
found at
mini.net/cetus/
oo_uml.html

It is important to note that the design steps discussed in this section are iterative.
That is, they may be executed incrementally, along with additional OOA activities,
until a completed design is produced.

22.1.4 A Uniﬁed Approach to OOD
In Chapter 21, we noted that Grady Booch, James Rumbaugh, and Ivar Jacobson com-
bined the best features of their individual object-oriented analysis and design meth-
ods into a uniﬁed method. The result, called the Uniﬁed Modeling Language has become
widely used throughout the industry.4

During analysis modeling (Chapter 21), the user model and structural model views
are represented. These provide insight into the usage scenarios for the system (pro-
viding guidance for behavioral modeling) and establish a foundation for the imple-
mentation and environment model views by identifying and describing the static
structural elements of the system.

UML is organized into two major design activities: system design and object design.
The primary objective of UML system design is to represent the software architecture.
Bennett, McRobb, and Farmer [BEN99] discuss this issue in the following way: 

In terms of object-oriented development, the conceptual architecture is concerned with the
structure of the static class model and the connections between components of the model.
The module architecture describes the way the system is divided into subsystems or mod-
ules and how they communicate by exporting and importing data. The code architecture
defines how the program code is organized into files and directories and grouped into
libraries. The execution architecture focuses on the dynamic aspects of the system and the
communication between components as tasks and operations execute.

System design focuses
on software
architecture and the
deﬁnition of
subsystems. Object
design describes
objects at a level of
detail that can be
implemented in a
programming
language.

The deﬁnition of the “subsystems” noted by Bennett et al. is a primary concern dur-
ing UML system design. 

UML object design focuses on a description of objects and their interactions with
one another. A detailed specification of attribute data structures and a procedural
design of all operations are created during object design. The visibility5 for all class
attributes is deﬁned and interfaces between objects are elaborated to deﬁne the details
of a complete messaging model.

System and object design in UML are extended to consider the design of user interfaces,
data management with the system to be built, and task management for the subsystems
that have been speciﬁed. User interface design in UML draws on the same concepts and
principles discussed in Chapter 15. The user model view drives the user interface design
process, providing a scenario that is elaborated iteratively to become a set of interface classes.6

4 Booch, Rumbaugh, and Jacobson have written a set of three deﬁnitive books on UML. The inter-

ested reader should see [BOO99], [RUM99], and [JAC99].

5 Visibility indicates whether an attribute is public (available across all instantiations of the class),
private (available only for the class that speciﬁes it), or protected (an attribute that may be used
by the class that speciﬁes it and its subclasses).

6 Today, most interface classes are part of a library of reusable software components. This expe-

dites the design and implementation of GUIs. 

CHAPTER 22 OBJECT-ORIENTED DESIGN

611

FIGURE 22.3
Process ﬂow for
OOD

System
design

Object
design

Human interface

design

Object-oriented

analysis

Task management

design

Data management

design

Data management design establishes a set of classes and collaborations that allow the 
system (product) to manage persistent data (e.g., ﬁles and databases). Task manage-
ment  design  establishes  the  infrastructure  that  organizes  subsystems  into  tasks 
and  then  manages  task  concurrency.  The  process  ﬂow  for  design  is  illustrated  in 
Figure 22.3.7

Throughout the UML design process, the user model view and structure model
view are elaborated into the design representation outlined above. This elaboration
activity is discussed in the sections that follow.

22.2 THE SYSTEM DESIGN PROCESS

System design develops the architectural detail required to build a system or prod-
uct. The system design process encompasses the following activities:

?

What are 
the steps of
the system design
process?

Identify concurrency that is dictated by the problem.

• Partition the analysis model into subsystems.
•
• Allocate subsystems to processors and tasks.
• Develop a design for the user interface.
• Choose a basic strategy for implementing data management.
•

Identify global resources and the control mechanisms required to access them.

7 Recall that OOA is an iterative activity. It is entirely possible that the analysis model will be

revised as a consequence of design work.

612

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The concepts of
coupling and cohesion
(Chapter 13) can be
applied at the
subsystem level. Strive
to achieve good
functional
independence as you
design subsystems.

?

What 
criteria 

guide us in the
design of
subsystems?

• Design an appropriate control mechanism for the system, including task

management.

• Consider how boundary conditions should be handled.
• Review and consider trade-offs.

In the sections that follow, design activities related to each of these steps are con-
sidered in more detail.

22.2.1 Partitioning the Analysis Model
One of the fundamental analysis principles (Chapter 11) is partitioning. In OO system
design, we partition the analysis model to deﬁne cohesive collections of classes, rela-
tionships, and behavior. These design elements are packaged as a subsystem.

In general, all of the elements of a subsystem share some property in common.
They all may be involved in accomplishing the same function; they may reside within
the same product hardware, or they may manage the same class of resources. Sub-
systems are characterized by their responsibilities; that is, a subsystem can be iden-
tiﬁed by the services that it provides [RUM91]. When used in the OO system design
context, a service is a collection of operations that perform a speciﬁc function (e.g.,
managing word-processor ﬁles, producing a three-dimensional rendering, translat-
ing an analog video signal into a compressed digital image).

As subsystems are deﬁned (and designed), they should conform to the following

design criteria:

• The subsystem should have a well-deﬁned interface through which all com-

munication with the rest of the system occurs.

• With the exception of a small number of “communication classes,” the

classes within a subsystem should collaborate only with other classes within
the subsystem.

• The number of subsystems should be kept low.
• A subsystem can be partitioned internally to help reduce complexity.

When  two  subsystems  communicate  with  one  another,  they  can  establish  a
client/server link or a peer-to-peer link [RUM91]. In a client/server link, each of the
subsystems takes on one of the roles implied by client and server. Service ﬂows from
server to client in only one direction. In a peer-to-peer link, services may ﬂow in either
direction. 

When a system is partitioned into subsystems, another design activity, called lay-
ering, also occurs. Each layer [BUS96] of an OO system contains one or more sub-
systems and represents a different level of abstraction of the functionality required
to accomplish system functions. In most cases, the levels of abstraction are deter-
mined by the degree to which the processing associated with a subsystem is visible
to an end-user.

?

How do I
create a

layered design?

CHAPTER 22 OBJECT-ORIENTED DESIGN

613

For example, a four-layer architecture might might include (1) a presentation layer
(the subsystems associated with the user interface), (2) an application layer (the sub-
systems that perform the processing associated with the application), (3) a data for-
matting layer (the subsystems that prepare the data for processing), and (4) a database
layer (the subsystems associated with data management). Each layer moves deeper
into the system, representing increasingly more environment-speciﬁc processing.

Buschmann and his colleagues [BUS96] suggest the following design approach for

layering:

1. Establish layering criteria. That is, decide how subsystems will be grouped in

a layered architecture.

2. Determine the number of layers. Too many introduce unnecessary complex-

ity; too few may harm functional independence.

3. Name the layers and allocate subsystems (with their encapsulated classes) to
a layer. Be certain that communication between subsystems (classes) on one
layer and other subsystems (classes) at another layer follow the design phi-
losophy for the architecture.8

4. Design interfaces for each layer.
5. Reﬁne the subsystems to establish the class structure for each layer.
6. Deﬁne the messaging model for communication between layers.
7. Review the layer design to ensure that coupling between layers is minimized

(a client/server protocol can help accomplish this).
Iterate to reﬁne the layered design.

8.

22.2.2 Concurrency and Subsystem Allocation
The dynamic aspect of the object-behavior model provides an indication of concur-
rency among classes (or subsystems). If classes (or subsystems) are not active at the
same time, there is no need for concurrent processing. This means that the classes
(or subsystems) can be implemented on the same processor hardware. On the other
hand, if classes (or subsystems) must act on events asynchronously and at the same
time, they are viewed as concurrent. When subsystems are concurrent, two alloca-
tion options exist: (1) Allocate each subsystem to an independent processor or (2)
allocate the subsystems to the same processor and provide concurrency support
through operating system features.

Concurrent tasks are deﬁned [RUM91] by examining the state diagram for each
object. If the ﬂow of events and transitions indicates that only a single object is active
at any one time, a thread of control has been established. The thread of control 

In most cases, a multi-
processor
implementation
increases complexity
and technical risk.
Whenever possible,
choose the simplest
processor architecture
that will get the job
done.

8 In a closed architecture, messages from one layer may be sent only to the adjacent lower layer. In

an open architecture, messages may be sent to any lower layer.

614

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

continues even when one object sends a message to another object, as long as the
ﬁrst object waits for a response. If, however, the ﬁrst object continues processing after
sending a message, the thread of control splits.

Tasks in an OO system are designed by isolating threads of control. For exam-
ple, while the SafeHome security system is monitoring its sensors, it can also be
dialing the central monitoring station for verification of connection. Since the
objects involved in both of these behaviors are active at the same time, each rep-
resents a separate thread of control and each can be defined as a separate task.
If the monitoring and dialing activities occur sequentially, a single task could be
implemented.

To determine which of the processor allocation options is appropriate, the designer
must consider performance requirements, costs, and the overhead imposed by inter-
processor communication.

22.2.3 The Task Management Component
Coad and Yourdon [COA91] suggest the following strategy for the design of the objects
that manage concurrent tasks:

• The characteristics of the task are determined.
• A coordinator task and associated objects are deﬁned.
• The coordinator and other tasks are integrated.

The characteristics of a task are determined by understanding how the task is initi-
ated. Event-driven and clock-driven tasks are the most commonly encountered. Both
are activated by an interrupt, but the former receives an interrupt from some outside
source (e.g., another processor, a sensor) while that latter is governed by a system
clock. 

In addition to the manner in which a task is initiated, the priority and criticality of
the task must also be determined. High-priority tasks must have immediate access
to system resources. High-criticality tasks must continue to operate even if resource
availability is reduced or the system is operating in a degraded state.

Once the characteristics of the task have been determined, object attributes and
operations required to achieve coordination and communication with other tasks are
deﬁned. The basic task template (for a task object) takes the form [COA91]

Task name—the name of the object
Description—a narrative describing the purpose of the object
Priority—task priority (e.g., low, medium, high)
Services—a list of operations that are responsibilities of the object
Coordinates by—the manner in which object behavior is invoked
Communicates via—input and output data values relevant to the task

This template description can then be translated into the standard design model
(incorporating representation of attributes and operations) for the task object(s).

“Discipline and
focused awareness 
. . . contribute to the
act of creation.”
John Poppy 

XRef
Most of the classes
necessary to build a
modern interface
already exist and are
available to the
designer. The design of
the interface follows
the approach deﬁned in
Chapter 15.

CHAPTER 22 OBJECT-ORIENTED DESIGN

615

22.2.4 The User Interface Component
Although the user interface component is implemented within the context of the prob-
lem domain, the interface itself represents a critically important subsystem for most
modern applications. The OO analysis model (Chapter 21) contains usage scenarios
(called use-cases) and a description of the roles that users play (called actors) as they
interact with the system. These serve as input to the user interface design process.
Once the actor and its usage scenario are deﬁned, a command hierarchy is identi-
ﬁed. The command hierarchy deﬁnes major system menu categories (the menu bar or
tool palette) and all subfunctions that are available within the context of a major sys-
tem menu category (the menu windows). The command hierarchy is reﬁned iteratively
until every use-case can be implemented by navigating the hierarchy of functions.

Because a wide variety of user interface development environments already exist,
the design of GUI elements is not necessary. Reusable classes (with appropriate attri-
butes and operations) already exist for windows, icons, mouse operations, and a wide
variety of other interaction functions. The implementer need only instantiate objects
that have appropriate characteristics for the problem domain.

22.2.5 The  Data Management Component
Data management encompasses two distinct areas of concern: (1) the management
of data that are critical to the application itself and (2) the creation of an infrastruc-
ture for storage and retrieval of objects. In general, data management is designed in
a layered fashion. The idea is to isolate the low-level requirements for manipulating
data structures from the higher-level requirements for handling system attributes.

Within the system context, a database management system is often used as a com-
mon data store for all subsystems. The objects required to manipulate the database
are members of reusable classes that are identiﬁed using domain analysis (Chapter 21)
or are supplied directly by the database vendor. A detailed discussion of database
design for OO systems is beyond the scope of this book.9

The design of the data management component includes the design of the attri-
butes and operations required to manage objects. The relevant attributes are appended
to every object in the problem domain and provide information that answers the ques-
tion, “How do I store myself?” Coad and Yourdon [COA91] suggest the creation of an
object-server class “with services to (a) tell each object to save itself and (b) retrieve
stored objects for use by other design components.” 

As an example of data management for the sensor object discussed as part of the
SafeHome security system, the design could specify a flat file called “sensor.” Each
record would correspond to a named instance of sensor and would contain the val-
ues of each sensor attribute for that named instance. Operations within the object-
server class would enable a speciﬁc object to be stored and retrieved when it is needed

9 Interested readers should refer to [BRO91], [TAY92], or [RAO94].

616

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 22.4
A model of 
collaboration
between 
subsystems

Client

subsystem

Request

Request

Request

Peer

subsystem

Contract

Server

subsystem

Contract

Peer

subsystem

Contract

by the system. For more complex objects, it might be necessary to specify a relational
database or an object-oriented database to accomplish the same function.

22.2.6 The Resource Management Component
A variety of different resources are available to an OO system or product; and in many
instances, subsystems compete for these resources at the same time. Global system
resources can be external entities (e.g., a disk drive, processor, or communication
line) or abstractions (e.g., a database, an object). Regardless of the nature of the
resource, the software engineer should design a control mechanism for it. Rumbaugh
and his colleagues [RUM91] suggest that each resource should be owned by a
“guardian object.” The guardian object is the gatekeeper for the resource, controlling
access to it and moderating conﬂicting requests for it. 

22.2.7 Intersubsystem Communication
Once each subsystem has been speciﬁed, it is necessary to deﬁne the collaborations
that exist between the subsystems. The model that we use for object-to-object col-
laboration can be extended to subsystems as a whole. Figure 22.4 illustrates a col-
laboration model. As we noted earlier in this chapter, communication can occur by
establishing a client/server link or a peer-to-peer link. Referring to the figure, we
must specify the contract that exists between subsystems. Recall that a contract pro-
vides an indication of the ways in which one subsystem can interact with another. 
The following design steps can be applied to specify a contract for a subsystem

[WIR90]:

1. List each request that can be made by collaborators of the subsys-

tem. Organize the requests by subsystem and deﬁne them within one or
more appropriate contracts. Be sure to note contracts that are inherited from
superclasses.

?

What design
steps are

required to
specify a
“contract” for a
subsystem?

CHAPTER 22 OBJECT-ORIENTED DESIGN

617

Contract

Type

Collaborators

Class(es)

Operation(s)

Message Format

FIGURE 22.5 Subsystem collaboration table

Every contract between
subsystems is
manifested by one or
more messages that
move between objects
within the subsystems.

2. For each contract, note the operations (both inherited and private)

that are required to implement the responsibilities implied by the
contract. Be sure to associate the operations with speciﬁc classes that reside
within a subsystem.

3. Considering one contract at a time, create a table of the form shown

in Figure 22.5. For each contract, the following entries are made in the
table:

Type—the type of contract (i.e., client/server or peer-to-peer).
Collaborators—the names of the subsystems that are parties to the con-

tract.

Class—the names of the classes (contained within a subsystem) that sup-

port services implied by the contract.

Operation—the names of the operations (within the class) that implement

the services.

Message format—the message format required to implement the interac-

tion between collaborators.

4.

Draft an appropriate message description for each interaction between the
subsystems.
If the modes of interaction between subsystems are complex, a sub-
system-collaboration diagram, illustrated in Figure 22.6 is created.
The collaboration graph is similar in form to the event ﬂow diagram dis-
cussed in Chapter 21. Each subsystem is represented along with its interac-
tions with other subsystems. The contracts that are invoked during an
interaction are noted as shown. The details of the interaction are determined
by looking up the contract in the subsystem collaboration table (Figure 22.5)

618

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Control
panel

subsystem

Request for status

Assign zone
Test status

Sensor

subsystem

Request for system status

Specification of type of alarm

Periodic status check

Request for alarm notification

Periodic check-in

Require for configuration update

FIGURE 22.6
Abbreviated
subsystem 
collaboration
graph for Safe-
Home

Central

communication

subsystem

22.3 THE OBJECT DESIGN PROCESS

Borrowing from a metaphor that was introduced earlier in this book, the OO system
design might be viewed as the ﬂoor plan of a house. The ﬂoor plan speciﬁes the pur-
pose of each room and the architectural features that connect the rooms to one
another and to the outside environment. It is now time to provide the details that are
required to build each room. In the context of OOD, object design focuses on the
“rooms.” 

Bennett and his colleagues [BEN99] discuss object design in the following way:

Object design is concerned with the detailed design of the objects and their interactions. It is
completed within the overall architecture deﬁned during system design and according to
agreed design guidelines and protocols. Object design is particularly concerned with the spec-
iﬁcation of attribute types, how operations function, and how objects are linked to other objects.

It is at this stage that the basic concepts and principles associated with component-
level design (Chapter 16) come into play. Local data structures are deﬁned (for attri-
butes) and algorithms (for operations) are designed.

22.3.1 Object Descriptions
A design description of an object (an instance of a class or subclass) can take one of
two forms [GOL83]: (1) a protocol description that establishes the interface of an object
by deﬁning each message that the object can receive and the related operation that
the object performs when it receives the message or (2) an implementation descrip-
tion that shows implementation details for each operation implied by a message that
is passed to an object. Implementation details include information about the object's
private part; that is, internal details about the data structures that describe the object’s
attributes and procedural details that describe operations.

Be sure that the
architecture has been
deﬁned before you
begin working on
object design. Don’t
let the architecture just
happen.

CHAPTER 22 OBJECT-ORIENTED DESIGN

619

The protocol description is nothing more than a set of messages and a corre-
sponding comment for each message. For example, a portion of the protocol descrip-
tion for the object motion sensor (described earlier) might be

MESSAGE (motion.sensor) -->  read: RETURNS sensor.ID, sensor.status;

This describes the message required to read the sensor. Similarly,

MESSAGE (motion.sensor) --> set: SENDS sensor.ID, sensor.status;

sets or resets the status of the sensor.

For a large system with many messages, it is often possible to create message cat-
egories. For example, message categories for the SafeHome system object might
include system conﬁguration messages, monitoring messages, event messages, and
so forth.

An implementation description of an object provides the internal ("hidden") details
that are required for implementation but are not necessary for invocation. That is,
the designer of the object must provide an implementation description and must
therefore create the internal details of the object. However, another designer or imple-
menter who uses the object or other instances of the object requires only the proto-
col description but not the implementation description. 

An implementation description is composed of the following information: (1) a
speciﬁcation of the object's name and reference to class; (2) a speciﬁcation of private
data structure with indication of data items and types; (3) a procedural description of
each operation or, alternatively, pointers to such procedural descriptions. The imple-
mentation description must contain sufﬁcient information to provide for proper han-
dling of all messages described in the protocol description.

Cox [COX85] characterizes the difference between the information contained in
the protocol description and that contained in the implementation description in terms
of "users" and "suppliers" of services. A user of the service provided by an object must
be familiar with the protocol for invoking the service; that is, for specifying what is
desired. The supplier of the service (the object itself) must be concerned with how
the service is to be supplied to the user; that is, with implementation details. 

22.3.2 Designing Algorithms and Data Structures
A variety of representations contained in the analysis model and the system design pro-
vide a speciﬁcation for all operations and attributes. Algorithms and data structures are
designed using an approach that differs little from the data design and component-level
design approaches discussed for conventional software engineering.

An algorithm is created to implement the speciﬁcation for each operation. In many
cases, the algorithm is a simple computational or procedural sequence that can be
implemented as a self-contained software module. However, if the speciﬁcation of
the operation is complex, it may be necessary to modularize the operation. Conven-
tional component-level design techniques can be used to accomplish this.

To achieve the beneﬁts
of information hiding
(Chapter 13), anyone
who intends to use an
object needs only the
protocol description.
The implementation
description contains
detail that should be
“hidden” from those
with no need to know.

XRef
Virtually every concept
presented in Chapter 13
is applicable here. Be
sure you’re familiar
with the topics
presented there.

620

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

?

Is there a
way to
categorize
operations
(methods)?

An operation is reﬁned
in much the same way
that we reﬁne a
function in
conventional design.
Write a processing
narrative, do a
grammatical parse,
and isolate new
operations at a lower
level of abstraction.

Data structures are designed concurrently with algorithms. Since operations invari-
ably manipulate the attributes of a class, the design of the data structures that best
reﬂect the attributes will have a strong bearing on the algorithmic design of the cor-
responding operations.

Although many different types of operations exist, they can generally be divided
into three broad categories: (1) operations that manipulate data in some way (e.g.,
adding, deleting, reformatting, selecting), (2) operations that perform a computa-
tion, and (3) operations that monitor an object for the occurrence of a controlling
event. 

For example, the SafeHome processing narrative contains the sentence fragments:
"sensor is assigned a number and type" and "a master password is programmed for
arming and disarming the system." These two phrases indicate a number of things:

• That an assign operation is relevant for the sensor object.
• That a program operation will be applied to the system object.
• That arm and disarm are operations that apply to system (also that system

status may ultimately be deﬁned (using data dictionary notation) as 

system status = [armed | disarmed]

The operation program is allocated during OOA, but during object design it will be
reﬁned into a number of more speciﬁc operations that are required to conﬁgure the
system. For example, after discussions with product engineering, the analyst, and
possibly the marketing department, the designer might elaborate the original pro-
cessing narrative and write the following for program (potential operations—verbs—
are underlined):

Program enables the SafeHome user to conﬁgure the system once it has been installed. The
user can (1) install phone numbers; (2) deﬁne delay times for alarms; (3) build a sensor table
that contains each sensor ID, its type, and location; and (4) load a master password. 

Therefore, the designer has reﬁned the single operation program and replaced it
with the operations: install, define, build, and load. Each of these new operations
becomes part of the system object, has knowledge of the internal data structures
that implement the object's attributes, and is invoked by sending the object messages
of the form

MESSAGE (system) --> install: SENDS telephone.number;

This implies that, to provide the system with an emergency phone number, an install
message will be sent to system.

Verbs connote actions or occurrences. In the context of object design formaliza-
tion, we consider not only verbs but also descriptive verb phrases and predicates
(e.g., "is equal to") as potential operations. The grammatical parse is applied recur-
sively until each operation has been reﬁned to its most-detailed level.

CHAPTER 22 OBJECT-ORIENTED DESIGN

621

Once the basic object model is created, optimization should occur. Rumbaugh and

his colleagues [RUM91] suggest three major thrusts for OOD design optimization:

• Review the object-relationship model to ensure that the implemented design

leads to efﬁcient utilization of resources and ease of implementation. Add
redundancy where necessary.

• Revise attribute data structures and corresponding operation algorithms to

enhance efﬁcient processing.

• Create new attributes to save derived information, thereby avoiding recom-

putation.

A detailed discussion of OO design optimization is beyond the scope of this book.
The interested reader should refer to [RUM91] and [CHA93]. For a discussion of how
these concepts translate into the UML process, the reader should examine [JAC99]
and [RUM99].

22.3.3 Program Components and Interfaces
An important aspect of software design quality is modularity; that is, the speciﬁcation
of program components (modules) that are combined to form a complete program.
The object-oriented approach deﬁnes the object as a program component that is itself
linked to other components (e.g., private data, operations). But deﬁning objects and
operations is not enough. During design, we must also identify the interfaces between
objects and the overall structure (considered in an architectural sense) of the objects.
Although a program component is a design abstraction, it should be represented
in the context of the programming language used for implementation. To accom-
modate OOD, the programming language to be used for implementation should be
capable of creating the following program component (modeled after Ada):

PACKAGE  program-component-name IS 

TYPE speciﬁcation of data objects 

•
• 
• 

PROC speciﬁcation of related operations . . . 

PRIVATE 

data structure details for objects 

PACKAGE BODY program-component-name IS 
PROC operation.1 (interface description) IS 

• 
• 
• 

END 
PROC operation.n (interface description) IS 

• 
• 
• 

END 

END program-component-name

622

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Referring to the Ada-like PDL (program design language) just shown, a program
component is speciﬁed by indicating both data objects and operations. The speciﬁ-
cation part of the component indicates all data objects (declared with the TYPE state-
ment) and the operations (PROC for procedure) that act on them. The private part
(PRIVATE) of the component provides otherwise hidden details of data structure and
processing. In the context of our earlier discussion, the PACKAGE is conceptually sim-
ilar to objects discussed throughout this chapter.

The ﬁrst program component to be identiﬁed should be the highest-level module
from which all processing originates and all data structures evolve. Referring once
again to the SafeHome example, we can deﬁne the highest-level program component
as

PROCEDURE SafeHome software

The SafeHome software component can be coupled with a preliminary design for the
following packages (objects): 

PACKAGE system IS 
TYPE system data 
PROC install, deﬁne, build, load 
PROC display, reset, query, modify, call 
PRIVATE 

PACKAGE BODY system IS 
PRIVATE

system.id IS STRING LENGTH (8);
veriﬁcation phone.number, telephone.number, ... 
IS STRING LENGTH (8);
sensor.table DEFINED

sensor.type IS STRING LENGTH (2), 
sensor.number, alarm.threshold IS NUMERIC;

PROC install RECEIVES (telephone.number)

{design detail for operation install}

•
•
•

END system  
PACKAGE sensor IS 
TYPE sensor data 
PROC read, set, test
PRIVATE 

PACKAGE BODY sensor IS 
PRIVATE

sensor.id IS STRING LENGTH (8);
sensor.status IS STRING LENGTH (8);
alarm.characteristics DEFINED

threshold, signal type, signal level IS NUMERIC, 

hardware.interface DEFINED

type, a/d.characteristics, timing.data IS NUMERIC,

CHAPTER 22 OBJECT-ORIENTED DESIGN

623

END sensor

•
•
•

END SafeHome software

Data objects and corresponding operations are speciﬁed for each of the program
components for SafeHome software. The ﬁnal step in the object design process com-
pletes all information required to fully implement data structure and types contained
in the PRIVATE portion of the package and all procedural detail contained in the PACK-
AGE BODY.

To illustrate the detail design of a program component, we reconsider the sensor
package described earlier. The data structures for sensor attributes have already
been deﬁned. Therefore, the ﬁrst step is to deﬁne the interfaces for each of the oper-
ations attached to sensor:

PROC read (sensor.id, sensor.status: OUT);
PROC set (alarm.characteristics, hardware.interface: IN)
PROC test (sensor.id, sensor.status, alarm.characteristics: OUT);

Stepwise refinement
and structured
programming
(Chapter 16) are
used at this stage 
to complete the
design of each
operation.

The next step requires stepwise reﬁnement of each operation associated with the
sensor package. To illustrate the reﬁnement, we develop a processing narrative (an
informal strategy) for read:

When the sensor object receives a read message, the read process is invoked. The process
determines the interface and signal type, polls the sensor interface, converts A/D charac-
teristics into an internal signal level, and compares the internal signal level to a threshold
value. If the threshold is exceeded, the sensor status is set to "event." Otherwise, the sen-
sor status is set to "no event." If an error is sensed while polling the sensor, the sensor sta-
tus is set to "error."

Given the processing narrative, a PDL description of the read process can be devel-
oped:

PROC read (sensor.id, sensor.status: OUT);

raw.signal IS BIT STRING
IF (hardware.interface.type = "s" & alarm.characteristics.signal.type = "B"
THEN

GET (sensor, exception: sensor.status := error) raw.signal;
CONVERT raw.signal TO internal.signal.level;
IF internal.signal.level > threshold 
THEN sensor.status := "event";
ELSE sensor.status := "no event";

ENDIF

ELSE {processing for other types of s interfaces would be speciﬁed}
ENDIF
RETURN sensor.id, sensor.status;

END read

624

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The PDL representation of the read operation can be translated into the appropriate
implementation language. The functions GET and CONVERT are assumed to be avail-
able as part of a run-time library.

22.4 DESIGN PATTERNS

XRef
Patterns exist at the
architecture and the
component levels. For
further discussion, see
Chapter 14.

The best designers in any ﬁeld have an uncanny ability to see patterns that charac-
terize a problem and corresponding patterns that can be combined to create a solu-
tion. Gamma and his colleagues [GAM95] discuss this when they state:

[Y]ou’ll find recurring patterns of classes and communicating objects in many object-
oriented systems. These patterns solve speciﬁc design problems and make object-oriented
design more flexible, elegant, and ultimately reusable. They help designers reuse suc-
cessful designs by basing new designs on prior experience. A designer who is familiar
with such patterns can apply them immediately to design problems without having to
rediscover them.

Throughout the OOD process, a software engineer should look for every opportunity
to reuse existing design patterns (when they meet the needs of the design) rather
than creating new ones.

WebRef
An excellent paper
entitled “Non-Software
Examples of Software
Design Patterns” provides
insight:
www.agcs.com/
patterns/papers/
patexamples.htm

22.4.1 Describing a Design Pattern
Mature engineering disciplines make use of thousands of design patterns. For exam-
ple, a mechanical engineer uses a two-step, keyed shaft as a design pattern. Inher-
ent in the pattern are attributes (the diameters of the shaft, the dimensions of the
keyway, etc.) and operations (e.g., shaft rotation, shaft connection). An electrical engi-
neer uses an integrated circuit (an extremely complex design pattern) to solve a spe-
ciﬁc element of a new problem. All design patterns can be described by specifying
the following information [GAM95]:

“[Patterns] constitute
a ‘grass roots’ effort
to build on the
collective experience
of skilled designers
and software
engineers.”
Frank Buschmann
et al.

the name of the pattern
the intent of the pattern
the “design forces” that motivate the pattern
the solution that mitigates these forces
the classes that are required to implement the solution
the responsibilities and collaboration among solution classes

•
•
•
•
•
•
• guidance that leads to effective implementation
•
example source code or source code templates
cross-references to related design patterns
•

The design pattern name is itself an abstraction that conveys signiﬁcant meaning
once the applicability and intent are understood. Design forces describe the data, func-
tional, or behavioral requirements associated with part of the software for which the

CHAPTER 22 OBJECT-ORIENTED DESIGN

625

pattern is to be applied. In addition forces deﬁne the constraints that may restrict the
manner in which the design is to be derived. In essence, design forces describe the
environment and conditions that must exist to make the design pattern applicable.
The pattern characteristics (classes, responsibilities, and collaborations) indicate the
attributes of the design that may be adjusted to enable the pattern to accommodate
a variety of problems. These attributes represent characteristics of the design that
can be searched (e.g., via a database) so that an appropriate pattern can be found.
Finally, guidance associated with the use of a design pattern provides an indication
of the ramiﬁcations of design decisions.

The names of objects and subsystems (potential design patterns) should be cho-
sen with care. As we discuss in Chapter 27, one of the key technical problems in soft-
ware reuse is simply the inability to ﬁnd existing reusable patterns when hundreds
or thousands of candidate patterns exist. The search for the “right” pattern is aided
immeasurably by a meaningful pattern name along with a set of characteristics that
help in classifying the object [PRE95].

22.4.2 Using Patterns in Design
In an object-oriented system, design patterns10 can be used by applying two differ-
ent mechanisms: inheritance and composition. Inheritance is a fundamental OO con-
cept and was described in detail in Chapter 20. Using inheritance, an existing design
pattern becomes a template for a new subclass. The attributes and operations that
exist in the pattern become part of the subclass.

Composition is a concept that leads to aggregate objects. That is, a problem may
require objects that have complex functionality (in the extreme, a subsystem accom-
plishes this). The complex object can be assembled by selecting a set of design pat-
terns and composing the appropriate object (or subsystem). Each design pattern is
treated as a black box, and communication among the patterns occurs only via well-
deﬁned interfaces.

Gamma and his colleagues [GAM95] suggest that object composition should be
favored over inheritance when both options exist. Rather than creating large and
sometimes unmanageable class hierarchies (the consequence of the overuse of inher-
itance), composition favors small class hierarchies and objects that remain focused
on one objective. Composition uses existing design patterns (reusable components)
in an unaltered form.

“A design pattern
becomes an
AntiPattern when it
creates more
problems than it
solves.”
William Brown
et al. 

WebRef
The Portland Pattern
Repository publishes an
evolving collection of
design patterns at:
c2.com/ppr

Good design always
strives for simplicity.
Therefore, opt for
composition when it
leads to simpler
inheritance structures.

22.5 OBJECT-ORIENTED PROGRAMMING

Although all areas of object technologies have received signiﬁcant attention within
the software community, no subject has produced more books, more discussion, and

10 Buschmann [BUS96] and Gamma et al. [GAM95] among many others have written catalogs of

design patterns for use in OO systems. 

626

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

more debate than object-oriented programming (OOP). Hundreds of books have been
written on C++ and Java programming, and hundreds more are dedicated to less
widely used OO languages. 

The software engineering viewpoint stresses OOA and OOD and considers OOP
(coding) an important, but secondary, activity that is an outgrowth of analysis and
design. The reason for this is simple. As the complexity of systems increases, the
design architecture of the end product has a significantly stronger influence on its
success than the programming language that has been used. And yet, “language wars”
continue to rage.

The details of OOP are best left to books dedicated to the subject. The interested
reader should refer to one or more of the OOP books noted in the Further Readings
and Information Sources section at the end of this chapter.

22.6 SUMMARY

Object-oriented  design  translates  the  OOA  model  of  the  real  world  into  an 
implementation-speciﬁc model that can be realized in software. The OOD process
can be described as a pyramid composed of four layers. The foundation layer focuses
on the design of subsystems that implement major system functions. The class layer
speciﬁes the overall object architecture and the hierarchy of classes required to imple-
ment a system. The message layer indicates how collaboration between objects will
be realized, and the responsibilities layer identiﬁes the attributes and operations that
characterize each class.

Like OOA, there are many different OOD methods. UML is an attempt to provide
a single approach to OOD that is applicable in all application domains. UML and other
methods approach the design process through two levels of abstraction—design of
subsystems (architecture) and design of individual objects.

During system design, the architecture of the object-oriented system is devel-
oped. In addition to developing subsystems, their interactions, and their place-
ment  in  architectural  layers,  system  design  considers  the  user  interaction
component, a task management component, and a data management compo-
nent. These subsystem components provide a design infrastructure that enables
the application to operate effectively. The object design process focuses on the
description of data structures that implement class attributes, algorithms that
implement operations, and messages that enable collaborations and object rela-
tionships. 

Design patterns allow the designer to create the system architecture by integrat-
ing reusable components. Object-oriented programming extends the design model
into the executable domain. An OO programming language is used to translate the
classes, attributes, operations, and messages into a form that can be executed by a
machine.

CHAPTER 22 OBJECT-ORIENTED DESIGN

627

REFERENCES

Fichman, R. and C. Kemerer, "Object-Oriented and Conceptual Design

[BEN99] Bennett, S., S. McRobb, and R. Farmer, Object Oriented System Analysis and
Design Using UML, McGraw-Hill, 1999.
[BIH92] Bihari, T. and P. Gopinath, “Object-Oriented Real-Time Systems: Concepts
and Examples,” Computer, vol. 25, no. 12, December 1992, pp. 25–32.
[BOO94] Booch, G., Object-Oriented Analysis and Design, 2nd ed., Benjamin Cum-
mings, 1994.
[BOO99] Booch, G., I. Jacobson, J. Rumbaugh, The Uniﬁed Modeling Language User
Guide, Addison-Wesley, 1999.
[BRO91] Brown, A.W., Object-Oriented Databases, McGraw-Hill, 1991.
[BUS96] Buschmann, F., et al., A System of Patterns: Pattern Oriented System Archi-
tecture, Wiley, 1996.
[CHA93] De Champeaux, D., D. Lea, and P. Faure, Object-Oriented System Develop-
ment, Addison-Wesley, 1993.
[COA91] Coad, P. and E. Yourdon, Object-Oriented Design, Prentice-Hall, 1991.
[COX85] Cox, B., "Software ICs and Objective-C," UnixWorld, Spring 1985. 
[DAV95] Davis, A., “Object-Oriented Requirements to Object-Oriented Design: An
Easy Transition?” Journal of Systems Software, vol. 30, 1995, pp. 151–159. 
[DOU99] Douglass, B., Real-Time UML: Developing Efﬁcient Objects for Embedded Sys-
tems, Addison-Wesley, 1999.
[FIC92]
Methodologies," Computer, vol. 25, no. 10, October 1992, pp. 22–39.
[GAM95] Gamma, E., et al., Design Patterns, Addison-Wesley, 1995.
[GOL83] Goldberg, A. and D. Robson, Smalltalk-80: The Language and Its Implemen-
tation, Addison-Wesley, 1983. 
[JAC92]
[JAC99]
Addison-Wesley, 1999. 
[MEY90] Meyer, B., Object-Oriented Software Construction, 2nd ed., Prentice-Hall,
1988.
[PRE95] Pree, W., Design Patterns for Object-Oriented Software Development, Addison-
Wesley, 1995.
[RUM91] Rumbaugh, J., et al., Object-Oriented Modeling and Design, Prentice-Hall,
1991.
[RUM99] Rumbaugh, J., I. Jacobson, and G. Booch, The Unified Modeling Language
Reference Manual, Addison-Wesley, 1999. 
[RAO94] Rao, B.A., Object-Oriented Databases: Technology, Applications and Products,
McGraw-Hill, 1994.
[TAY92} Taylor, D.A., Object-Oriented Information Systems, Wiley, 1992.
[WIR90] Wirfs-Brock, R., B. Wilkerson, and L. Weiner, Designing Object-Oriented Soft-
ware, Prentice-Hall, 1990. 

Jacobson, I., Object-Oriented Software Engineering, Addison-Wesley, 1992.
Jacobson, I., G. Booch, J. Rumbaugh, Uniﬁed Software Development Process,

628

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

PROBLEMS AND POINTS TO PONDER

22.1. The design pyramid for OOD differs somewhat from the pyramid described for
conventional software design (Chapter 13). Discuss the differences and similarities
of the two pyramids.

22.2. How do OOD and structured design differ? What aspects of these two design
methods are the same?

22.3. Review the ﬁve criteria for effective OO modularity discussed in Section 22.1.2.
Using the design approach described later in the chapter, demonstrate how these ﬁve
criteria are achieved.

22.4. Using outside references on UML, prepare a one-hour tutorial for your class.
Be sure to show all important diagrammatic modeling conventions used in UML.

22.5. Select an older OOD method presented in Section 22.1.3 and prepare a one-
hour tutorial for your class. Be sure to show all important diagrammatic modeling
conventions that the authors suggest.

22.6. Discuss how the use-case can serve as an important source of information for
design.

22.7. Research a GUI development environment and show how the user interaction
component is implemented in the real world. What design patterns are offered and
how are they used?

22.8. Task management for OO systems can be quite complex. Do some research
of OOD methods for real-time systems (e.g., [BIH92] or [DOU99]) and determine how
task management is achieved in that context.

22.9. Discuss how the data management component is implemented in a typical
OO development environment.

22.10. Write a two- or three-page paper on object-oriented databases and discuss
how they might be used to develop the data management component. 

22.11. How does a designer recognize tasks that must be concurrent?

22.12. Apply the OOD approach discussed in this chapter to ﬂesh out the design for
the SafeHome system. Deﬁne all relevant subsystems and develop object designs for
important classes.

22.13. Apply OOD approach discussed in this chapter to the PHTRS system described
in Problem 12.13. 

22.14. Describe a video game and apply OOD approach discussed in this chapter
to represent its design. 

CHAPTER 22 OBJECT-ORIENTED DESIGN

629

22.15. You are responsible for the development of an electronic mail (e-mail) sys-
tem to be implemented on a PC network. The e-mail system will enable users to cre-
ate letters to be mailed to another user, general distribution, or a speciﬁc address list.
Letters can be read, copied, stored, and the like. The e-mail system will use existing
word-processing capability to create letters. Using this description as a starting point,
derive a set of requirements and apply OOD techniques to create a top-level design
for the e-mail system. 

22.16. A small island nation has decided to build an air trafﬁc control (ATC) system
for its one airport. The system is speciﬁed as follows: 

All aircraft landing at the airport must have a transponder that transmits aircraft type and
ﬂight data in high-density packed format to the ATC ground station. The ATC ground sta-
tion can query an aircraft for speciﬁc information. When the ATC ground station receives
data, it is unpacked and stored in an aircraft database. A computer graphics display is cre-
ated from the stored information and displayed for an air trafﬁc controller. The display is
updated every 2 seconds. All information is analyzed to determine if "dangerous situations"
are present. The air trafﬁc controller can query the database for speciﬁc information about
any plane displayed on the screen. 

Using OOD, create a design for the ATC system. Do not attempt to implement it!

FURTHER READINGS AND INFORMATION SOURCES

In addition to the many references in this chapter, books by Gossain and Graham
(Object Modeling and Design Strategies, SIGS Books, 1998); Meyer (Object-Oriented
Software Construction, 2nd ed., Prentice-Hall, 1997); Reil (Object-Oriented Design
Through Heuristics, Addison-Wesley, 1996); and Walden and Nerson (Seamless Object-
Oriented Software Architecture: Analysis and Design of Reliable Systems, Prentice-Hall,
1995) cover OOD in considerable detail.  Fowler (Refactoring: Improving the Design of
Existing Code, Addison-Wesley, 1999) addresses the use of object-oriented techniques
to redesign and rebuild old programs to improve their design quality. 

Many recent books published on object-oriented design emphasize UML. Those
serious about applying UML in their work should acquire [BOO99], [RUM99], and
[JAC99]. In addition, many of the books referenced in the Further Reading and Infor-
mation Sources section of Chapter 21 also address design in considerable detail.

The use of design patterns for the development of object-oriented software has
important implications for component-based software engineering, reusability in gen-
eral, and the overall quality of resultant systems. In addition to [BUS96] and [GAM95],
many recent books are dedicated to the subject:

Ambler, S.W., Process Patterns: Building Large-Scale Systems Using Object Technology, Cam-

bridge University Press, 1999.

Coplien, J.O. and D.C. Schmidt, Pattern Languages of Program Design, Addison-Wesley, 1995.

630

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Fowler, M., Analysis Patterns: Reusable Object Models, Addison-Wesley, 1996.

Larman, C., Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design,

Prentice-Hall, 1997. 

Martin, R.C., et al., Pattern Languages of Program Design 3, Addison-Wesley, 1997.

Rising, L. and J. Coplien (eds.), The Patterns Handbook: Techniques, Strategies, and Applica-

tions, SIGS Books, 1998.

Pree, W., Design Patterns for Object-Oriented Software Development, Addison-Wesley, 1995. 

Vlissides, J., Pattern Hatching: Design Patterns Applied, Addison-Wesley, 1998.

Vlissides, J.M., J.O. Coplien, and N. Kerth, Pattern Languages of Program Design 2, Addison-

Wesley, 1996.

Hundreds of books have been published on object-oriented programming. A sam-

pling of OOP language-speciﬁc books follows:

C++:

Cohoon, J.P., C++ Program Design: An Introduction to Programming and Object-Oriented 

Design, McGraw Hill, 1998.

Barclay, K. and J. Savage, Object-Oriented Design with C++, Prentice-Hall, 1997.

Eiffel: Thomas, P. and R. Weedon, Object-Oriented Programming in Eiffel, Addison-Wesley, 

1997.

Jezequel, J.M., Object-Oriented Software Engineering with Eiffel, Addison-Wesley, 1996. 

Java:

Coad, P., M. Mayﬁeld, and J. Kern, Java Design: Building Better Apps and Applets, 2nd ed., 

Prentice-Hall, 1998. 

Lewis, J. and  W. Loftus, Java Software Solutions: Foundations of Program, Addison-

Wesley, 1997.

Smalltalk:  Sharp, A., Smalltalk by Example: The Developer's Guide, McGraw-Hill, 1997. 
LaLonde, W.R. and J.R. Pugh, Programming in Smalltalk, Prentice-Hall, 1995.

Books that cover OOD topics using two or more OO programming languages provide
insight and comparison of language features. Titles include:

Drake, C., Object-Oriented Programming With C++ and Smalltalk, Prentice-Hall, 1998. 

Joyner, I., Objects Unencapsulated: Java, Eiffel and C++, Prentice-Hall, 1999. 

Zeigler, B.P., Objects and Systems: Principled Design with Implementations in C++ and Java,

Springer-Verlag, 1997.

A wide variety of information sources on object-oriented design and related sub-
jects is available on the Internet. An up-to-date list of World Wide Web references
that are relevant to OOD can be found at the SEPA Web site:
http://www.mhhe.com/engcs/compsci/pressman/resources/OOD.mhtml

C H A P T E R

K E Y
C O N C E P T S
class-level
testing   . . . . . . . 644
CRC model
review. . . . . . . . . 634
fault-based
testing   . . . . . . . 639
integration . . . . . 637
interclass tests. . 645
OOA review . . . . 634
OOD review . . . . 635
partition testing. 644
random testing. . 644
scenario-based
testing. . . . . . . . . 641
structure tests . . 643
test case design. 637
unit testing. . . . . 636
validation . . . . . . 637

23 OBJECT-ORIENTED TESTING
The objective of testing, stated simply, is to ﬁnd the greatest possible num-

ber of errors with a manageable amount of effort applied over a realistic
time span. Although this fundamental objective remains unchanged for
object-oriented software, the nature of OO programs changes both testing strat-
egy and testing tactics. 

It might be argued that, as OOA and OOD mature, greater reuse of design
patterns will mitigate the need for heavy testing of OO systems. Exactly the
opposite is true. Binder [BIN94b] discusses this when he states:

[E]ach reuse is a new context of usage and retesting is prudent. It seems likely that
more, not less, testing will be needed to obtain high reliability in object-oriented 
systems. 

The testing of OO systems presents a new set of challenges to the software
engineer. The deﬁnition of testing must be broadened to include error discov-
ery techniques (formal technical reviews) applied to OOA and OOD models.
The completeness and consistency of OO representations must be assessed as
they are built. Unit testing loses much of its meaning, and integration strate-
gies change signiﬁcantly. In summary, both testing strategies and testing tac-
tics must account for the unique characteristics of OO software.

Q U I C K
L O O K

What is it? The architecture of
object-oriented software results in
a  series  of  layered  subsystems
that encapsulate collaborating classes. Each of
these system elements (subsystems and classes)
perform functions that help to achieve system
requirements. It is necessary to test an OO system
at  a  variety  of  different  levels  in  an  effort  to
uncover errors that may occur as classes collab-
orate with one another and subsystems commu-
nicate across architectural layers. 

Who does it? Object-oriented testing is performed by

software engineers and testing specialists.

Why is it important? You have to execute the pro-
gram before it gets to the customer with the spe-

ciﬁc intent of removing all errors, so that the cus-
tomer will not experience the frustration associ-
ated with a poor-quality product. In order to ﬁnd
the highest possible number of errors, tests must
be conducted systematically and test cases must
be designed using disciplined techniques. 

What are the steps? OO testing is strategically simi-
lar to the testing of conventional systems, but it is
tactically different. Because the OO analysis and
design models are similar in structure and con-
tent to the resultant OO program, “testing” begins
with the review of these models. Once code has
been generated, OO testing begins “in the small”
with class testing. A series of tests are designed
that  exercise  class  operations  and  examine

631

632

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Q U I C K
L O O K

whether errors exist as one class
collaborates with other classes.
As classes are integrated to form
a subsystem, thread-based, use-based, and clus-
ter testing, along with fault-based approaches,
are applied to fully exercise collaborating classes.
Finally, use-cases (developed as part of the OO
analysis model) are used to uncover errors at the
software validation level. 

What is the work product? A set of test cases to exer-
cise classes, their collaborations, and behaviors is
designed  and  documented;  expected  results
deﬁned; and actual results recorded.

How do I ensure that I’ve done it right? When you
begin testing, change your point of view. Try hard
to “break” the software!  Design test cases in a dis-
ciplined fashion and review the test cases you do
create for thoroughness.

23.1 BROADENING THE VIEW OF TESTING

“Because of their
ability to detect and
correct defects in
upstream work
products, technical
reviews are at least
as important in
controlling cost and
schedule as testing.”
Steve McConnell 

The construction of object-oriented software begins with the creation of analysis and
design models (Chapters 21 and 22). Because of the evolutionary nature of the OO
software engineering paradigm, these models begin as relatively informal represen-
tations of system requirements and evolve into detailed models of classes, class con-
nections  and  relationships,  system  design  and  allocation,  and  object  design
(incorporating a model of object connectivity via messaging). At each stage, the mod-
els can be tested in an attempt to uncover errors prior to their propagation to the next
iteration.

It can be argued that the review of OO analysis and design models is especially
useful because the same semantic constructs (e.g., classes, attributes, operations,
messages) appear at the analysis, design, and code levels. Therefore, a problem in
the deﬁnition of class attributes that is uncovered during analysis will circumvent side
effects that might occur if the problem were not discovered until design or code (or
even the next iteration of analysis). 

For example, consider a class in which a number of attributes are deﬁned during
the ﬁrst iteration of OOA. An extraneous attribute is appended to the class (due to a
misunderstanding of the problem domain). Two operations are then specified to
manipulate the attribute. A review is conducted and a domain expert points out the
error. By eliminating the extraneous attribute at this stage, the following problems
and unnecessary effort may be avoided during analysis:

1. Special subclasses may have been generated to accommodate the unneces-
sary attribute or exceptions to it. Work involved in the creation of unneces-
sary subclasses has been avoided.

2. A misinterpretation of the class deﬁnition may lead to incorrect or extraneous

class relationships.

CHAPTER 23 OBJECT-ORIENTED TESTING

633

3. The behavior of the system or its classes may be improperly characterized to

accommodate the extraneous attribute.

If the error is not uncovered during analysis and propagated further, the following
problems could occur (and will have been avoided because of the earlier review) dur-
ing design:

1.

Improper allocation of the class to subsystem and/or tasks may occur during
system design.

2. Unnecessary design work may be expended to create the procedural design

for the operations that address the extraneous attribute.

3. The messaging model will be incorrect (because messages must be designed

for the operations that are extraneous).

If the error remains undetected during design and passes into the coding activity, con-
siderable effort will be expended to generate code that implements an unnecessary
attribute, two unnecessary operations, messages that drive interobject communica-
tion, and many other related issues. In addition, testing of the class will absorb more
time than necessary. Once the problem is ﬁnally uncovered, modiﬁcation of the sys-
tem must be carried out with the ever-present potential for side effects that are caused
by change.

During later stages of their development, OOA and OOD models provide substantial
information about the structure and behavior of the system. For this reason, these
models should be subjected to rigorous review prior to the generation of code. 

All object-oriented models should be tested (in this context, the term testing is used
to incorporate formal technical reviews) for correctness, completeness, and consis-
tency [MGR94] within the context of the model’s syntax, semantics, and pragmatics
[LIN94].

There’s an old saying
about “nipping
problems in the bud.”
If you spend time
reviewing the OOA and
OOD models, that’s
what you’ll do.

23.2 TESTING OOA AND OOD MODELS

Analysis and design models cannot be tested in the conventional sense, because they
cannot be executed. However, formal technical reviews (Chapter 8) can be used to
examine the correctness and consistency of both analysis and design models.

23.2.1 Correctness of OOA and OOD Models
The notation and syntax used to represent analysis and design models will be tied to
the speciﬁc analysis and design method that is chosen for the project. Hence, syn-
tactic correctness is judged on proper use of the symbology; each model is reviewed
to ensure that proper modeling conventions have been maintained. 

During analysis and design, semantic correctness must be judged based on the
model’s conformance to the real world problem domain. If the model accurately

634

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

reﬂects the real world (to a level of detail that is appropriate to the stage of develop-
ment at which the model is reviewed), then it is semantically correct. To determine
whether the model does, in fact, reﬂect the real world, it should be presented to prob-
lem domain experts, who will examine the class deﬁnitions and hierarchy for omis-
sions and ambiguity. Class relationships (instance connections) are evaluated to
determine whether they accurately reﬂect real world object connections.1

23.2.2 Consistency of OOA and OOD Models
The consistency of OOA and OOD models may be judged by “considering the rela-
tionships among entities in the model. An inconsistent model has representations in
one part that are not correctly reﬂected in other portions of the model” [MGR94].

To assess consistency, each class and its connections to other classes should be
examined. The class-responsibility-collaboration model and an object-relationship
diagram can be used to facilitate this activity. As we noted in Chapter 21, the CRC
model is composed on CRC index cards. Each CRC card lists the class name, its respon-
sibilities (operations), and its collaborators (other classes to which it sends messages
and on which it depends for the accomplishment of its responsibilities). The collab-
orations imply a series of relationships (i.e., connections)  between classes of the OO
system. The object-relationship model provides a graphic representation of the con-
nections between classes.  All of this information can be obtained from the OOA
model (Chapter 21).

To evaluate the class model the following steps have been recommended [MGR94]:

1. Revisit the CRC model and the object-relationship model. Cross check

2.

3.

to ensure that all collaborations implied by the OOA model are properly 
represented.
Inspect the description of each CRC index card to determine if a dele-
gated responsibility is part of the collaborator’s deﬁnition. For exam-
ple, consider a class deﬁned for a point-of-sale checkout system, called credit
sale. This class has a CRC index card illustrated in Figure 23.1. For this collec-
tion of classes and collaborations, we ask whether a responsibility (e.g., read
credit card) is accomplished if delegated to the named collaborator (credit
card). That is, does the class credit card have an operation that enables it to
be read? In this case the answer is, “Yes.” The object-relationship is traversed
to ensure that all such connections are valid.
Invert the connection to ensure that each collaborator that is asked for
service is receiving requests from a reasonable source. For example, if the
credit card class receives a request for purchase amount from the credit sale
class, there would be a problem. Credit card does not know the purchase amount.

1 Use-cases can be invaluable in tracking analysis and design models against real world usage sce-

narios for the OO system.

OOA Models

?

What steps
should we
take to review
the class model?

XRef
Additional suggestions
for conducting a CRC
model review are
presented in Chapter
21.

CHAPTER 23 OBJECT-ORIENTED TESTING

635

Class name: Credit sale

Class type: Transaction event

Class characteristics: Nontangible, atomic, sequential, permanent, guarded

Responsibilities:                                             Collaborators:

Read credit card
Get authorization
Post purchase amount

Generate bill

Credit card
Credit authority
Product ticket
Sales ledger
Audit file
Bill

FIGURE 23.1 An example CRC index card used for review

4. Using the inverted connections examined in step 3, determine

whether other classes might be required and whether responsibili-
ties are properly grouped among the classes.

5. Determine whether widely requested responsibilities might be com-

bined into a single responsibility. For example, read credit card and get
authorization occur in every situation. They might be combined into a validate
credit request responsibility that incorporates getting the credit card number
and gaining authorization.

6. Steps 1 through 5 are applied iteratively to each class and through

each evolution of the OOA model.

Once the OOD model (Chapter 22) is created, reviews of the system design and
the object design should also be conducted. The system design depicts the overall
product architecture, the subsystems that compose the product, the manner in which
subsystems are allocated to processors, the allocation of classes to subsystems, and
the design of the user interface. The object model presents the details of each class
and the messaging activities that are necessary to implement collaborations between
classes.

The system design is reviewed by examining the object-behavior model developed
during OOA and mapping required system behavior against the subsystems designed
to accomplish this behavior. Concurrency and task allocation are also reviewed within
the context of system behavior. The behavioral states of the system are evaluated to
determine which exist concurrently. Use-case scenarios are used to  exercise the user
interface design. 

OOD Model

636

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The object model should be tested against the object-relationship network to ensure
that all design objects contain the necessary attributes and operations to implement
the collaborations deﬁned for each CRC index card. In addition, the detailed speciﬁ-
cation of operation details (i.e., the algorithms that implement the operations) are
reviewed using conventional inspection techniques.

23.3 OBJECT-ORIENTED TESTING STRATEGIES

“The best tester isn’t
the one who ﬁnds
the most bugs . . .
The best tester is the
one who gets the
most bugs ﬁxed.”
Cem Kaner et al. 

Class testing for OO
software is equivalent
to module unit testing
for conventional
software. It is not
advisable to test
operations in isolation.

The classical strategy for testing computer software begins with “testing in the small”
and works outward toward “testing in the large.” Stated in the jargon of software test-
ing (Chapter 18), we begin with unit testing, then progress toward integration test-
ing, and culminate with validation and system testing. In conventional applications,
unit testing focuses on the smallest compilable program unit—the subprogram (e.g.,
module, subroutine, procedure, component). Once each of these units has been tested
individually, it is integrated into a program structure while a series of regression tests
are run to uncover errors due to interfacing between the modules and side effects
caused by the addition of new units. Finally, the system as a whole is tested to ensure
that errors in requirements are uncovered.

23.3.1 Unit Testing in the OO Context
When object-oriented software is considered, the concept of the unit changes. Encap-
sulation drives the deﬁnition of classes and objects. This means that each class and
each instance of a class (object) packages attributes (data) and the operations (also
known as methods or services) that manipulate these data. Rather than testing an
individual module, the smallest testable unit is the encapsulated class or object.
Because a class can contain a number of different operations and a particular oper-
ation may exist as part of a number of different classes, the meaning of unit testing
changes dramatically.

We can no longer test a single operation in isolation (the conventional view of unit
testing) but rather as part of a class. To illustrate, consider a class hierarchy in which
an operation X is deﬁned for the superclass and is inherited by a number of subclasses.
Each subclass uses operation X, but it is applied within the context of the private
attributes and operations that have been deﬁned for the subclass. Because the con-
text in which operation X is used varies in subtle ways, it is necessary to test opera-
tion X in the context of each of the subclasses. This means that testing operation X
in a vacuum (the traditional unit testing approach) is ineffective in the object-oriented
context.

Class testing for OO software is the equivalent of unit testing for conventional soft-
ware.2 Unlike unit testing of conventional software, which tends to focus on the algo-
rithmic detail of a module and the data that ﬂow across the module interface, class

2 Test case design methods for OO classes are discussed in Sections 23.4 through 23.6.

CHAPTER 23 OBJECT-ORIENTED TESTING

637

testing for OO software is driven by the operations encapsulated by the class and the
state behavior of the class.

23.3.2 Integration Testing in the OO Context
Because object-oriented software does not have a hierarchical control structure, con-
ventional top-down and bottom-up integration strategies have little meaning. In addi-
tion, integrating operations one at a time into a class (the conventional incremental
integration approach) is often impossible because of the “direct and indirect interac-
tions of the components that make up the class” [BER93].

There are two different strategies for integration testing of OO systems [BIN94a].
The ﬁrst, thread-based testing, integrates the set of classes required to respond to one
input or event for the system. Each thread is integrated and tested individually. Regres-
sion testing is applied to ensure that no side effects occur. The second integration
approach, use-based testing, begins the construction of the system by testing those
classes (called independent classes) that use very few (if any) of server classes. After
the independent classes are tested, the next layer of classes, called dependent classes,
that use the independent classes are tested. This sequence of testing layers of depen-
dent classes continues until the entire system is constructed. Unlike conventional
integration, the use of drivers and stubs (Chapter 18) as replacement operations is to
be avoided, when possible.

Cluster testing [MGR94] is one step in the integration testing of OO software.
Here, a cluster of collaborating classes (determined by examining the CRC and
object-relationship model) is exercised by designing test cases that attempt to
uncover errors in the collaborations. 

23.3.3 Validation Testing in an OO Context
At the validation or system level, the details of class connections disappear. Like con-
ventional validation, the validation of OO software focuses on user-visible actions
and user-recognizable output from the system. To assist in the derivation of valida-
tion tests, the tester should draw upon the use-cases (Chapter 20) that are part of the
analysis model. The use-case provides a scenario that has a high likelihood of uncov-
ered errors in user interaction requirements.

Conventional black-box testing methods can be used to drive validations tests. In
addition, test cases may be derived from the object-behavior model and from event
ﬂow diagram created as part of OOA.

The OO testing
integration strategy
focuses on groups of
classes that collaborate
or communicate in
some manner.

XRef
Virtually all of the
black-box testing
methods discussed in
Chapter 17 are
applicable for OO.

23.4  TEST CASE DESIGN FOR OO SOFTWARE

Test case design methods for OO software are still evolving. However, an overall
approach to OO test case design has been deﬁned by Berard [BER93]:

1. Each test case should be uniquely identiﬁed and explicitly associated with the

class to be tested.

638

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

2. The purpose of the test should be stated.
3. A list of testing steps should be developed for each test and should contain

[BER93]:
a. A list of speciﬁed states for the object that is to be tested.
b. A list of messages and operations that will be exercised as a consequence

of the test.

c. A list of exceptions that may occur as the object is tested.
d. A list of external conditions (i.e., changes in the environment external to

the software that must exist in order to properly conduct the test).

e. Supplementary information that will aid in understanding or implementing

the test.

Unlike conventional test case design, which is driven by an input-process-output view
of software or the algorithmic detail of individual modules, object-oriented testing
focuses on designing appropriate sequences of operations to exercise the states of a
class.

23.4.1 The Test Case Design Implications of OO Concepts
As we have already seen, the OO class is the target for test case design. Because
attributes and operations are encapsulated, testing operations outside of the class is
generally unproductive. Although encapsulation is an essential design concept for
OO, it can create a minor obstacle when testing. As Binder [BIN94a] notes, “Testing
requires reporting on the concrete and abstract state of an object.” Yet, encapsula-
tion can make this information somewhat difﬁcult to obtain. Unless built-in opera-
tions are provided to report the values for class attributes, a snapshot of the state of
an object may be difﬁcult to acquire.

Inheritance also leads to additional challenges for the test case designer. We have
already noted that each new context of usage requires retesting, even though reuse
has been achieved. In addition, multiple inheritance3 complicates testing further by
increasing the number of contexts for which testing is required [BIN94a]. If subclasses
instantiated from a superclass are used within the same problem domain, it is likely
that the set of test cases derived for the superclass can be used when testing the sub-
class. However, if the subclass is used in an entirely different context, the superclass
test cases will have little applicability and a new set of tests must be designed.

23.4.2 Applicability of Conventional Test Case Design Methods
The white-box testing methods described in Chapter 17 can be applied to the oper-
ations deﬁned for a class. Basis path, loop testing, or data ﬂow techniques can help
to ensure that every statement in an operation has been tested. However, the con-

3 An OOD concept that should be used with extreme care.

WebRef
An excellent collection of
papers, resources, and a
bibliography on OO
testing can be found at
www.rbsc.com

CHAPTER 23 OBJECT-ORIENTED TESTING

639

cise structure of many class operations causes some to argue that the effort applied
to white-box testing might be better redirected to tests at a class level. 

Black-box testing methods are as appropriate for OO systems as they are for sys-
tems developed using conventional software engineering methods. As we noted ear-
lier in this chapter, use-cases can provide useful input in the design of black-box and
state-based tests [AMB95].

23.4.3 Fault-Based Testing4
The object of fault-based testing within an OO system is to design tests that have a high
likelihood of uncovering plausible faults. Because the product or system must con-
form to customer requirements, the preliminary planning required to perform fault-
based testing begins with the analysis model. The tester looks for plausible faults (i.e.,
aspects of the implementation of the system that may result in defects). To determine
whether these faults exist, test cases are designed to exercise the design or code. 

Consider a simple example.5 Software engineers often make errors at the bound-
aries of a problem. For example, when testing a SQRT operation that returns errors
for negative numbers, we know to try the boundaries: a negative number close to
zero and zero itself. "Zero itself" checks whether the programmer made a mistake
like

if (x > 0) calculate_the_square_root();

instead of the correct

if (x >= 0) calculate_the_square_root();

As another example, consider a Boolean expression:

if (a && !b || c)

Multicondition testing and related techniques probe for certain plausible faults in this
expression, such as

&& should be ||
! was left out where it was needed
There should be parentheses around !b || c

For each plausible fault, we design test cases that will force the incorrect expression
to fail. In the previous expression, (a=0, b=0, c=0) will make the expression as given
evaluate false. If the && should have been ||, the code has done the wrong thing and
might branch to the wrong path.

The strategy is to
hypothesize a set of
plausible faults and
then derive tests to
prove the hypothesis.

Because fault-based
testing occurs at a
detailed level, it is best
reserved for operations
and classes that are
critical or suspect.

4 Sections 23.4.3 through 23.4.7 have been adapted from an article by Brian Marick posted on the
Internet newsgroup comp.testing. This adaptation is included with the permission of the author.
For further discussion of these topics, see [MAR94].

5 The code presented in this and the following sections uses C++ syntax. For further information,

see any good book on C++.

640

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

?

What types
of faults are

encountered in
operation calls
and message
connections?

“If you want and
expect a program to
work, you will be
more likely to see a
working program—
you will miss
failures.”
Cem Kaner et al. 

Of course, the effectiveness of these techniques depends on how testers perceive
a "plausible fault." If real faults in an OO system are perceived to be "implausible,"
then this approach is really no better than any random testing technique. However,
if the analysis and design models can provide insight into what is likely to go wrong,
then fault-based testing can find significant numbers of errors with relatively low
expenditures of effort. 

Integration testing looks for plausible faults in operation calls or message connec-
tions. Three types of faults are encountered in this context: unexpected result, wrong
operation/message used, incorrect invocation.  To determine plausible faults as func-
tions (operations) are invoked, the behavior of the operation must be examined. 

Integration testing applies to attributes as well as to operations. The "behaviors"
of an object are deﬁned by the values that its attributes are assigned. Testing should
exercise the attributes to determine whether proper values occur for distinct types of
object behavior.

It is important to note that integration testing attempts to ﬁnd errors in the client
object, not the server. Stated in conventional terms, the focus of integration testing
is to determine whether errors exist in the calling code, not the called code.  The oper-
ation call is used as a clue, a way to ﬁnd test requirements that exercise the calling
code.

23.4.4 The Impact of OO Programming on Testing
There are several ways object-oriented programming can have an impact on testing.
Depending on the approach to OOP, 

• Some types of faults become less plausible (not worth testing for).
• Some types of faults become more plausible (worth testing now).
• Some new types of faults appear.

When an operation is invoked, it may be hard to tell exactly what code gets exer-
cised. That is, the operation may belong to one of many classes. Also, it can be hard
to determine the exact type or class of a parameter. When the code accesses it, it may
get an unexpected value. The difference can be understood by considering a con-
ventional function call: 

x = func (y);

For conventional software, the tester need consider all behaviors attributed to func
and nothing more. In an OO context, the tester must consider the behaviors of
base::func(), of derived::func(), and so on.  Each time func is invoked, the tester must
consider the union of all distinct behaviors. This is easier if good OO design practices
are followed and the difference between superclasses and subclasses (in C++ jargon,
these are called base classes and derived classes) are limited. The testing approach for
base and derived classes is essentially the same.  The difference is one of bookkeeping.  

CHAPTER 23 OBJECT-ORIENTED TESTING

641

Testing OO class operations is analogous to testing code that takes a function
parameter and then invokes it. Inheritance is a convenient way of producing poly-
morphic operations. At the call site, what matters is not the inheritance, but the poly-
morphism.  Inheritance  does  make  the  search  for  test  requirements  more
straightforward.

By virtue of OO software architecture and construction, are some types of faults
more plausible for an OO system and others less plausible? The answer is, “Yes.” For
example, because OO operations are generally smaller, more time tends to be spent
on integration because there are more opportunities for integration faults. Therefore,
integration faults become more plausible.

23.4.5 Test Cases and the Class Hierarchy
As noted earlier in this chapter, inheritance does not obviate the need for thorough
testing of all derived classes. In fact, it can actually complicate the testing process.
Consider the following situation. A class base contains operations inherited and
redeﬁned. A class derived redeﬁnes redeﬁned to serve in a local context. There is lit-
tle doubt the derived::redeﬁned() has to be tested because it represents a new design
and new code.  But does derived::inherited() have to be retested?

If derived::inherited() calls redefined and the behavior of redefined has changed,
derived::inherited() may mishandle the new behavior. Therefore, it needs new tests even
though the design and code have not changed. It is important to note, however, that
only a subset of all tests for derived::inherited() may have to be conducted. If part of the
design and code for inherited does not depend on redeﬁned (i.e., that does not call it
nor call any code that indirectly calls it), that code need not be retested in the derived
class.

Base::redeﬁned() and derived::redeﬁned() are two different operations with different
specifications and implementations. Each would have a set of test requirements
derived from the speciﬁcation and implementation. Those test requirements probe
for plausible faults: integration faults, condition faults, boundary faults, and so forth.
But the operations are likely to be similar. Their sets of test requirements will over-
lap. The better the OO design, the greater is the overlap. New tests need to be derived
only for those derived::redeﬁned() requirements that are not satisﬁed by the base::rede-
ﬁned() tests.

To summarize, the base::redeﬁned() tests are applied to objects of class derived.
Test inputs may be appropriate for both base and derived classes, but the expected
results may differ in the derived class.

23.4.6 Scenario-Based Test Design
Fault-based testing misses two main types of errors: (1) incorrect speciﬁcations and
(2) interactions among subsystems. When errors associated with incorrect speciﬁca-
tion occur, the product doesn't do what the customer wants. It might do the wrong

Even though a base
class has been
thoroughly tested, you
will still have to test all
classes derived from it.

642

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Scenario-based testing
will uncover errors that
occur when any actor
interacts with the OO
software.

Although scenario-
based testing has
merit, you will get a
higher return on time
invested by reviewing
use-cases when they
are developed during
OOA.

thing or it might omit important functionality. But in either circumstance, quality (con-
formance to requirements) suffers. Errors associated with subsystem interaction occur
when the behavior of one subsystem creates circumstances (e.g., events, data ﬂow)
that cause another subsystem to fail.

Scenario-based testing concentrates on what the user does, not what the product
does. This means capturing the tasks (via use-cases) that the user has to perform,
then applying them and their variants as tests.

Scenarios uncover interaction errors. But to accomplish this, test cases must be
more complex and more realistic than fault-based tests.  Scenario-based testing tends
to exercise multiple subsystems in a single test (users do not limit themselves to the
use of one subsystem at a time).

As an example, consider the design of scenario-based tests for a text editor. Use

cases follow:

Use-Case: Fix the Final Draft

Background: It's not unusual to print the "ﬁnal" draft, read it, and discover some annoy-
ing errors that weren't obvious from the on-screen image. This use-case describes the
sequence of events that occurs when this happens.

1. Print the entire document.
2. Move around in the document, changing certain pages.
3. As each page is changed, it's printed.
4. Sometimes a series of pages is printed.

This scenario describes two things: a test and speciﬁc user needs. The user needs are
obvious: (1) a method for printing single pages and (2) a method for printing a range
of pages. As far as testing goes, there is a need to test editing after printing (as well
as the reverse). The tester hopes to discover that the printing function causes errors
in the editing function; that is, that the two software functions are not properly inde-
pendent.

Use-Case: Print a New Copy

Background: Someone asks the user for a fresh copy of the document. It must be printed.

1. Open the document.
2. Print it.
3. Close the document.

Again, the testing approach is relatively obvious. Except that this document didn't
appear out of nowhere. It was created in an earlier task. Does that task affect this
one?

In many modern editors, documents remember how they were last printed.  By
default, they print the same way next time. After the Fix the Final Draft scenario, just
selecting "Print" in the menu and clicking the "Print" button in the dialog box will
cause the last corrected page to print again. So, according to the editor, the correct
scenario should look like this:

CHAPTER 23 OBJECT-ORIENTED TESTING

643

Use-Case: Print a New Copy

1. Open the document.
2. Select "Print" in the menu.
3. Check if you're printing a page range; if so, click to print the entire document.
4. Click on the Print button.
5. Close the document.

But this scenario indicates a potential speciﬁcation error. The editor does not do what
the user reasonably expects it to do. Customers will often overlook the check noted
in step 3 above. They will then be annoyed when they trot off to the printer and ﬁnd
one page when they wanted 100. Annoyed customers signal speciﬁcation bugs.

A test case designer might miss this dependency in test design, but it is likely that
the problem would surface during testing. The tester would then have to contend
with the probable response, "That's the way it's supposed to work!"

23.4.7 Testing Surface Structure and Deep Structure
Surface structure refers to the externally observable structure of an OO program. That
is, the structure that is immediately obvious to an end-user. Rather than performing
functions, the users of many OO systems may be given objects to manipulate in some
way. But whatever the interface, tests are still based on user tasks. Capturing these
tasks involves understanding, watching, and talking with representative users (and
as many nonrepresentative users as are worth considering).

There will surely be some difference in detail.  For example, in a conventional sys-
tem with a command-oriented interface, the user might use the list of all commands
as a testing checklist. If no test scenarios existed to exercise a command, testing has
likely overlooked some user tasks (or the interface has useless commands). In a object-
based interface, the tester might use the list of all objects as a testing checklist.

The best tests are derived when the designer looks at the system in a new or uncon-
ventional way. For example, if the system or product has a command-based inter-
face, more thorough tests will be derived if the test case designer pretends that
operations are independent of objects. Ask questions like, “Might the user want to
use this operation—which applies only to the Scanner object—while working with
the printer?" Whatever the interface style, test case design that exercises the surface
structure should use both objects and operations as clues leading to overlooked tasks. 
Deep structure refers to the internal technical details of an OO program. That is,
the structure that is understood by examining the design and/or code. Deep struc-
ture testing is designed to exercise dependencies, behaviors, and communication
mechanisms that have been established as part of the system and object design (Chap-
ter 22) of OO software. 

The analysis and design models are used as the basis for deep structure testing.
For example, the object-relationship diagram or the subsystem collaboration diagram
depicts collaborations between objects and subsystems that may not be externally

Structure testing occurs
at two levels: (1) tests
that exercise the
structure observable 
by the end-user and
(2) tests designed to
exercise the internal
program structure.

644

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

visible. The test case design then asks: “Have we captured (as a test) some task that
exercises the collaboration noted on the object-relationship diagram or the subsys-
tem collaboration diagram?  If not, why not?”

Design representations of class hierarchy provide insight into inheritance struc-
ture. Inheritance structure is used in fault-based testing. Consider a situation in which
an operation named caller has only one argument and that argument is a reference
to a base class. What might happen when caller is passed a derived class? What are
the differences in behavior that could affect caller? The answers to these questions
might lead to the design of specialized tests.

23.5 TESTING METHODS APPLICABLE AT THE CLASS LEVEL

In Chapter 17, we noted that software testing begins “in the small” and slowly pro-
gresses toward testing “in the large.” Testing in the small focuses on a single class
and the methods that are encapsulated by the class. Random testing and partition-
ing are methods that can be used to exercise a class during OO testing [KIR94].

23.5.1 Random Testing for OO Classes
To provide brief illustrations of these methods, consider a banking application in
which an account class has the following operations: open, setup, deposit, withdraw,
balance, summarize, creditLimit, and close [KIR94]. Each of these operations may be
applied for account, but certain constraints (e.g., the account must be opened before
other operations can be applied and closed after all operations are completed) are
implied by the nature of the problem. Even with these constraints, there are many
permutations of the operations. The minimum behavioral life history of an instance
of account includes the following operations:

open•setup•deposit•withdraw•close

This represents the minimum test sequence for account. However, a wide variety of
other behaviors may occur within this sequence:
open•setup•deposit•[deposit|withdraw|balance|summarize|creditLimit]n•withdraw•close

A variety of different operation sequences can be generated randomly. For example:

Test case r1:  
Test case r2:  

open•setup•deposit•deposit•balance•summarize•withdraw•close
open•setup•deposit•withdraw•deposit•balance•creditLimit•withdraw•close

These and other random order tests are conducted to exercise different class instance
life histories.

23.5.2 Partition Testing at the Class Level
Partition testing reduces the number of test cases required to exercise the class in
much the same manner as equivalence partitioning (Chapter 17) for conventional

The number of possible
permutations for
random testing can
grow quite large. A
strategy similar to
orthogonal array
testing (Chapter 17)
can be used to
improve testing
efﬁciency.

?

What
testing
options are
available at the
class level?

CHAPTER 23 OBJECT-ORIENTED TESTING

645

software. Input and output are categorized and test cases are designed to exercise
each category. But how are the partitioning categories derived?

State-based partitioning categorizes class operations based on their ability to change
the state of the class. Again considering the account class, state operations include
deposit and withdraw, whereas nonstate operations include balance, summarize, and
creditLimit. Tests are designed in a way that exercises operations that change state
and those that do not change state separately. Therefore,

open•setup•deposit•deposit•withdraw•withdraw•close
open•setup•deposit•summarize•creditLimit•withdraw•close

Test case p1:
Test case p2:
Test case p1 changes state, while test case p2 exercises operations that do not change
state (other than those in the minimum test sequence).

Attribute-based partitioning categorizes class operations based on the attributes
that they use. For the account class, the attributes balance and creditLimit can be used
to deﬁne partitions. Operations are divided into three partitions: (1) operations that
use creditLimit, (2) operations that modify creditLimit, and (3) operations that do not use
or modify creditLimit. Test sequences are then designed for each partition.

Category-based partitioning categorizes class operations based on the generic func-
tion that each performs. For example, operations in the account class can be cate-
gorized in initialization operations (open, setup), computational operations (deposit,
withdraw). queries (balance, summarize, creditLimit) and termination operations (close). 

23.6 INTERCLASS TEST CASE DESIGN

Test case design becomes more complicated as integration of the OO system begins.
It is at this stage that testing of collaborations between classes must begin. To illus-
trate “interclass test case generation” [KIR94], we expand the banking example intro-
duced in Section 23.5 to include the classes and collaborations noted in Figure 23.2.
The direction of the arrows in the ﬁgure indicates the direction of messages and the
labeling indicates the operations that are invoked as a consequence of the collabo-
rations implied by the messages. 

Like the testing of individual classes, class collaboration testing can be accom-
plished by applying random and partitioning methods, as well as scenario-based test-
ing and behavioral testing.

23.6.1 Multiple Class Testing
Kirani and Tsai [KIR94] suggest the following sequence of steps to generate multiple
class random test cases:

1. For each client class, use the list of class operations to generate a series of
random test sequences. The operations will send messages to other server
classes.

646

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

ATM
user

interface

cardinserted
password
deposit
withdraw
accntStatus
terminate

verifyStatus
depositStatus
dispenseCash
print AccntStat
read CardInfo
getCashAmnt

ATM

verifyAcct
verifyPIN
verifyPolicy
withdrawReq
depositReq

acctInfo

openAcct

initialDeposit
authorizeCard
deauthorize
closeAcct

validPIN
validAcct

Bank

creditLimit
accntType
balance
withdraw
deposit
close

Cashier

Account

Validation

info

FIGURE 23.2 Class collaboration diagram for banking application [KIR94]

2. For each message that is generated, determine the collaborator class and the

corresponding operation in the server object.

3. For each operation in the server object (that has been invoked by messages

sent from the client object), determine the messages that it transmits.

4. For each of the messages, determine the next level of operations that are

invoked and incorporate these into the test sequence.

To illustrate [KIR94], consider a sequence of operations for the bank class relative to
an ATM class (Figure 23.2):
verifyAcct•verifyPIN•[[verifyPolicy•withdrawReq]|depositReq|acctInfoREQ]n

A random test case for the bank class might be

test case r3 =

verifyAcct•verifyPIN•depositReq

In order to consider the collaborators involved in this test, the messages associated
with each of the operations noted in test case r3 is considered. Bank must collabo-
rate with ValidationInfo to execute the verifyAcct and verifyPIN. Bank must collab-
orate with account to execute depositReq. Hence, a new test case that exercises these
collaborations is
test case r4 = 

verifyAcctBank[validAcctValidationInfo]•verifyPINBank•
[validPinValidationInfo]•depositReq• [depositaccount]

CHAPTER 23 OBJECT-ORIENTED TESTING

647

FIGURE 23.3
State transition
diagram for
account class
[KIR94]

open

Empty
Empty
acct
acct

setup Accnt

Empty
Set up
acct
acct

deposit (initial)

Empty
Working
acct
acct

balance
credit
accntInfo

deposit

withdraw

withdrawal (final)

Empty
Dead
acct
acct

Nonworking

Empty
acct
acct

close

The approach for multiple class partition testing is similar to the approach used
for partition testing of individual classes. A single class is partitioned as discussed in
Section 23.4.5. However, the test sequence is expanded to include those operations
that are invoked via messages to collaborating classes. An alternative approach par-
titions tests based on the interfaces to a particular class. Referring to Figure 23.2, the
bank class receives messages from the ATM and cashier classes. The methods
within bank can therefore be tested by partitioning them into those that serve ATM
and those that serve cashier. State-based partitioning (Section 23.4.9) can be used
to reﬁne the partitions further.

23.6.2 Tests Derived from Behavior Models
In Chapter 21, we discussed the use of the state transition diagram as a model that rep-
resents the dynamic behavior of a class. The STD for a class can be used to help derive
a sequence of tests that will exercise the dynamic behavior of the class (and those
classes that collaborate with it). Figure 23.3 [KIR94] illustrates an STD for the account
class discussed earlier.6 Referring to the ﬁgure, initial transitions move through the
empty acct and setup acct states. The majority of all behavior for instances of the class
occurs while in the working acct state. A ﬁnal withdrawal and close cause the account
class to make transitions to the nonworking acct and dead acct states, respectively.

6 UML symbology is used for the STD shown in Figure 23.3. It differs slightly from the symbology

used for STDs in Part Three of this book.

648

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

The tests to be designed should achieve all state coverage [KIR94]. That is, the
operation sequences should cause the account class to make transition through all
allowable states:

test case s1:

open•setupAccnt•deposit (initial)•withdraw (ﬁnal)•close

It should be noted that this sequence is identical to the minimum test sequence dis-
cussed in Section 23.5.1.  Adding additional test sequences to the minimum sequence,

test case s2:
test case s3:

open•setupAccnt•deposit(initial)•deposit•balance•credit•withdraw (ﬁnal)•close
open•setupAccnt•deposit(initial)•deposit•withdraw•accntInfo•withdraw (ﬁnal)•close

Still more test cases could be derived to ensure that all behaviors for the class have
been adequately exercised. In situations in which the class behavior results in a col-
laboration with one or more classes, multiple STDs are used to track the behavioral
ﬂow of the system.

The state model can be traversed in a “breadth-ﬁrst” [MGR94] manner. In this con-
text, breadth ﬁrst implies that a test case exercise a single transition and that when a
new transition is to be tested only previously tested transitions are used.

Consider the credit card object discussed in Section 23.2.2. The initial state of
credit card is undefined (i.e., no credit card number has been provided). Upon read-
ing the credit card during a sale, the object takes on a defined state; that is, the
attributes card number and expiration date, along with bank specific identifiers are
defined. The credit card is submitted when it is sent for authorization and it is
approved when authorization is received. The transition of credit card from one
state to another can be tested by deriving test cases that cause the transition to
occur. A breadth-first approach to this type of testing would not exercise submit-
ted before it exercised undefined and defined. If it did, it would make use of transi-
tions that had not been previously tested and would therefore violate the breadth-first
criterion.

23.7 SUMMARY

The overall objective of object-oriented testing—to find the maximum number of
errors with a minimum amount of effort—is identical to the objective of conventional
software testing. But the strategy and tactics for OO testing differ signiﬁcantly. The
view of testing broadens to include the review of both the analysis and design model.
In addition, the focus of testing moves away from the procedural component (the
module) and toward the class.

Because the OO analysis and design models and the resulting source code are
semantically coupled, testing (in the form of formal technical reviews) begins during
these engineering activities. For this reason, the review of CRC, object-relationship,
and object-behavior models can be viewed as ﬁrst stage testing.

CHAPTER 23 OBJECT-ORIENTED TESTING

649

Once OOP has been accomplished, unit testing is applied for each class. The design
of tests for a class uses a variety of methods: fault-based testing, random testing, and
partition testing. Each of these methods exercises the operations encapsulated by the
class. Test sequences are designed to ensure that relevant operations are exercised.
The state of the class, represented by the values of its attributes, is examined to deter-
mine if errors exist. 

Integration testing can be accomplished using a thread-based or use-based strat-
egy. Thread-based testing integrates the set of classes that collaborate to respond to
one input or event. Use-based testing constructs the system in layers, beginning with
those classes that do not use server classes. Integration test case design methods
can also use random and partition tests. In addition, scenario-based testing and tests
derived from behavioral models can be used to test a class and its collaborators. A
test sequence tracks the ﬂow of operations across class collaborations. 

OO system validation testing is black-box oriented and can be accomplished by
applying the same black-box methods discussed for conventional software. How-
ever, scenario-based testing dominates the validation of OO systems, making the
use-case a primary driver for validation testing.

REFERENCES

[AMB95] Ambler, S., “Using Use Cases,” Software Development, July 1995, pp. 53–61.
[BER93] Berard, E.V., Essays on Object-Oriented Software Engineering, vol. 1, Addison-
Wesley, 1993. 
[BIN94a] Binder, R.V., “Testing Object-Oriented Systems: A Status Report,” American
Programmer, vol. 7, no. 4, April 1994, pp. 23–28.
[BIN94b] Binder, R.V., “Object-Oriented Software Testing,” CACM, vol. 37, no. 9, Sep-
tember 1994, p. 29.
[KIR94] Kirani, S. and W.T. Tsai, “Speciﬁcation and Veriﬁcation of Object-Oriented
Programs,” Technical Report TR 94-64, Computer Science Department, University of
Minnesota, December 1994.
[LIN94] Lindland, O.I., et al., “Understanding Quality in Conceptual Modeling,” IEEE
Software, vol. 11, no 4, July 1994, pp. 42–49.
[MAR94] Marick, B., The Craft of Software Testing, Prentice-Hall, 1994.
[MGR94] McGregor, J.D. and T.D. Korson, “Integrated Object-Oriented Testing and
Development Processes,” CACM, vol. 37, no. 9, September 1994, pp. 59–77.

PROBLEMS AND POINTS TO PONDER

23.1. In your own words, describe why the class is the smallest reasonable unit for
testing within an OO system.

650

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

23.2. Why do we have to retest subclasses that are instantiated from an existing
class, if the existing class has already been thoroughly tested? Can we use the test
cases designed for the existing class?

23.3. Why should “testing” begin with the OOA and OOD activities?

23.4. Derive a set of CRC index cards for SafeHome and conduct the steps noted in
Section 23.2.2 to determine if inconsistencies exist.

23.5. What is the difference between thread-based and use-based strategies for inte-
gration testing? How does cluster testing ﬁt in?

23.6. Apply random testing and partitioning to three classes deﬁned in the design
for the SafeHome system that you produced for Problem 22.12. Produce test cases
that indicate the operation sequences that will be invoked.

23.7. Apply multiple class testing and tests derived from the behavioral model to
the SafeHome design.

23.8. Derive tests using methods noted in Problems 23.6 and 23.7 for the PHTRS
system described in Problem 12.13. 

23.9. Derive tests using methods noted in Problems 23.6 and 23.7 for the video game
considered in Problem 22.14.

23.10. Derive tests using methods noted in Problems 23.6 and 23.7 for the e-mail
system considered in Problem 22.15.

23.11. Derive tests using methods noted in Problems 23.6 and 23.7 for the ATC sys-
tem considered in Problem 22.16.

23.12. Derive four additional tests using each of the methods noted in Problems
23.6 and 23.7 for the banking application presented in Sections 23.5 and 23.6.

FURTHER READINGS AND INFORMATION SOURCES

The literature for object-oriented testing is relatively sparse, although it has expanded
somewhat in recent years. Binder (Testing Object-Oriented Systems: Models, Patterns,
and Tools, Addison-Wesley, 2000) has written the most comprehensive treatment of
the subject published to date. Siegel and Muller (Object Oriented Software Testing: A
Hierarchical Approach, Wiley, 1996) proposed a practical testing strategy for OO sys-
tems. Marick (The Craft of Software Testing: Subsystem Testing Including Object-Based
and Object-Oriented Testing, Prentice-Hall, 1995) covers testing for both conventional
and OO software. 

Anthologies of important papers on OO testing have been edited by Kung et al.
(Testing Object-Oriented Software, IEEE Computer Society, 1998) and Braude (Object
Oriented Analysis, Design and Testing: Selected Readings, IEEE Computer Society, 1998).

CHAPTER 23 OBJECT-ORIENTED TESTING

651

These IEEE tutorials provide an interesting historical perspective on development in
OO testing.

Jorgensen (Software Testing: A Craftsman’s Approach, CRC Press, 1995) and McGre-
gor and Sykes (Object-Oriented Software Development, Van Nostrand-Reinhold, 1992)
present chapters dedicated to the topic. Beizer (Black-Box Testing, Wiley, 1995) dis-
cusses a variety of test case design methods that are appropriate in an OO context.
Binder (Testing Object-Oriented Systems, Addison-Wesley, 1996) and Marick [MAR94]
present detailed treatments of OO testing. In addition, many of the sources noted for
Chapter 17 are generally applicable to OO testing.

A wide variety of information sources on object-oriented testing and related sub-
jects is available on the Internet. An up-to-date list of World Wide Web references
that are relevant to OO testing can be found at the SEPA Web site:
http://www.mhhe.com/engcs/compsci/pressman/resources/OOT.mhtml

C H A P T E R

24 TECHNICAL METRICS FOR 

OBJECT-ORIENTED SYSTEMS

K E Y
C O N C E P T S
abstraction  . . . . 656
CK metrics . . . . . 658
class-oriented
metrics . . . . . . . . 658
design metrics . . 656
encapsulation . . . 655
inheritance . . . . . 656
information
hiding . . . . . . . . . 655
localization . . . . . 655
Lorenz and Kidd
metrics . . . . . . . . 661
MOOD metrics . . 662
operation-oriented
metrics . . . . . . . . 664
project management
metrics . . . . . . . . 665
testing metrics. . 664

Early in this book we noted that measurement and metrics are key com-

ponents of any engineering discipline—and object-oriented software engi-
neering is no exception. Sadly, the use of metrics for OO systems has
progressed much more slowly than the use of other OO methods. Ed Berard
[BER95] notes the irony of measurement when he states: 

Software people seem to have a love-hate relationship with metrics. On one hand,
they despise and distrust anything that sounds or looks like a measurement. They
are quick to point out the "ﬂaws" in the arguments of anyone who talks about mea-
suring software products, software processes, and (especially) software people. On
the other hand, these same people seem to have no problems identifying which pro-
gramming language is the best, the stupid things that managers do to "ruin" projects,
and who's methodology works in what situations.

The “love-hate relationship” that Berard notes is real. And yet, as OO sys-
tems become more pervasive, it is essential that software engineers have quan-
titative  measurements  for  assessing  the  quality  of  designs  at  both  the
architectural and component levels. These measures enable an engineer to
assess the software early in the process, making changes that will reduce com-
plexity and improve the long-term viability of the end product.

Q U I C K
L O O K

What is it? Building OO software
has been an engineering activ-
ity that relies more on collective
wisdom, folklore, and qualitative guidance than
on quantitative evaluation. OO metrics have been
introduced to help a software engineer use quan-
titative analysis to assess the quality of the design
before a system is built. The focus of OO metrics is
on the class—the fundamental building block of
the OO architecture.

Who does it? Software engineers use OO metrics to

help them build higher-quality software.

Why is it important? As we stated in the Quick Look
for Chapter 19, qualitative assessment of computer
software must be complemented with quantita-

tive analysis. A software engineer needs objec-
tive criteria to help guide the design of the OO
architecture, the classes and subsystems that pop-
ulate the architecture, and the operations and
attributes that constitute a class. The tester needs
quantitative guidance that will help in the selec-
tion of test cases and their targets. Technical met-
rics provide a basis from which analysis, design,
and testing can be conducted more objectively
and assessed more quantitatively.

What are the steps? The ﬁrst step in the measurement
process is to derive the software measures and met-
rics that are appropriate for the representation of
software  that  is  being  considered.  Next,  data
required  to  derive  the  formulated  metrics  are 

653

654

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Q U I C K
L O O K

collected. Once computed, appro-
priate metrics are analyzed based
on pre-established guidelines and
past data. The results of the analysis are interpreted
to gain insight into the quality of the software, and
the results of the interpretation lead to modiﬁca-
tion of work products arising out of analysis, design,
code, or test.

What is the work product? Software metrics that 
are  computed  using  data  collected  from  the

analysis and design models, source code, and test
cases.

How do I ensure that I’ve done it right? You should
establish the objectives of measurement before
the data collection begins, deﬁning each OO met-
ric in an unambiguous manner. Deﬁne only a few
metrics and then use them to gain insight into the
quality of a software engineering work product.  

24.1 THE INTENT OF OBJECT-ORIENTED METRICS

The primary objectives for object-oriented metrics are no different than those for met-
rics derived for conventional software:

•
•
•

to better understand the quality of the product
to assess the effectiveness of the process
to improve the quality of work performed at a project level

Each of these objectives is important, but for the software engineer, product quality must
be paramount. But how do we measure the quality of an OO system? What character-
istics of the design model can be assessed to determine whether the system will be easy
to implement, amenable to test, simple to modify, and most important, acceptable to
end-users? These questions are addressed throughout the remainder of this chapter.

24.2 THE DISTINGUISHING CHARACTERISTICS OF 

OBJECT-ORIENTED METRICS

Metrics for any engineered product are governed by the unique characteristics of the
product. For example, it would be meaningless to compute miles per gallon for an
electric automobile. The metric is sound for conventional (i.e., gasoline powered)
cars but it does not apply when the mode of propulsion changes radically. Object-
oriented software is fundamentally different than software developed using conven-
tional methods. For this reason, the metrics for OO systems must be tuned to the
characteristics that distinguish OO from conventional software.

Berard [BER95] deﬁnes ﬁve characteristics that lead to specialized metrics: local-
ization, encapsulation, information hiding, inheritance, and object abstraction tech-
niques. Each of these characteristics is discussed brieﬂy in the sections that follow.1

1 This discussion has been adapted from [BER95].

XRef
Technical metrics for
conventional software
are discussed in
Chapter 19.

XRef
Basic design concepts
are discussed in
Chapter 13. Their
application to OO
software is discussed in
Chapter 20.

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

655

24.2.1 Localization
Localization is a characteristic of software that indicates the manner in which infor-
mation is concentrated within a program. For example, conventional methods for
functional decomposition localize information around functions, which are typically
implemented as procedural modules. Data-driven methods localize information
around specific data structures. In the OO context, information is concentrated by
encapsulating both data and process within the bounds of a class or object.

Because conventional software emphasizes function as a localization mechanism,
software metrics have focused on the internal structure or complexity of functions
(e.g., module length, cohesion or cyclomatic complexity) or the manner in which
functions connect to one another (e.g., module coupling).

Since the class is the basic unit of an OO system, localization is based on objects.
Therefore, metrics should apply to the class (object) as a complete entity. In addition,
the relationship between operations (functions) and classes is not necessarily one to
one. Therefore, metrics that reﬂect the manner in which classes collaborate must be
capable of accommodating one-to-many and many-to-one relationships.

24.2.2 Encapsulation
Berard [BER95] defines encapsulation as “the packaging (or binding together) of a
collection of items. Low-level examples of encapsulation [for conventional software]
include records and arrays, [and] subprograms (e.g., procedures, functions, subrou-
tines, and paragraphs) are mid-level mechanisms for encapsulation.” 

For OO systems, encapsulation encompasses the responsibilities of a class, includ-
ing its attributes (and other classes for aggregate objects) and operations, and the
states of the class, as deﬁned by speciﬁc attribute values.

Encapsulation inﬂuences metrics by changing the focus of measurement from a
single module to a package of data (attributes) and processing modules (operations).
In addition encapsulation encourages measurement at a higher level of abstraction.
For example, later in this chapter metrics associated with the number of operations
per class will be introduced. Contrast this level of abstraction to conventional met-
rics that focus on counts of Boolean conditions (cyclomatic complexity) or line of
code counts. 

24.2.3 Information Hiding
Information hiding suppresses (or hides) the operational details of a program com-
ponent. Only the information necessary to access the component is provided to those
other components that wish to access it.

A well-designed OO system should encourage information hiding. Therefore, met-
rics that provide an indication of the degree to which hiding has been achieved should
provide an indication of the quality of the OO design.

656

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

24.2.4 Inheritance
Inheritance is a mechanism that enables the responsibilities of one object to be prop-
agated to other objects. Inheritance occurs throughout all levels of a class hierarchy.
In general, conventional software does not support this characteristic.

Because inheritance is a pivotal characteristic in many OO systems, many OO met-
rics focus on it. Examples (discussed later in this chapter) include number of children
(number of immediate instances of a class), number of parents (number of immedi-
ate generalizations), and class hierarchy nesting level (depth of a class in an inheri-
tance hierarchy).

24.2.5 Abstraction
Abstraction is a mechanism that enables the designer to focus on the essential details
of a program component (either data or process) with little concern for lower-level
details. As Berard states: “Abstraction is a relative concept. As we move to higher
levels of abstraction we ignore more and more details, i.e., we provide a more gen-
eral view of a concept or item. As we move to lower levels of abstraction, we intro-
duce more details, i.e., we provide a more speciﬁc view of a concept or item.”

Because a class is an abstraction that can be viewed at many different levels of
detail and in a number of different ways (e.g., as a list of operations, as a sequence
of states, as a series of collaborations), OO metrics represent abstractions in terms
of measures of a class (e.g., number of instances per class per application, number
or parameterized classes per application, and ratio of parameterized classes to non-
parameterized classes).

24.3 METRICS FOR THE OO DESIGN MODEL

There is much about object-oriented design that is subjective—an experienced designer
“knows” how to characterize an OO system so that it will effectively implement cus-
tomer requirements. But, as an OO design model grows in size and complexity, a
more objective view of the characteristics of the design can beneﬁt both the experi-
enced designer (who gains additional insight) and the novice (who obtains an indi-
cation of quality that would otherwise be unavailable).

In a detailed treatment of software metrics for OO systems, Whitmire [WHI97]

describes nine distinct and measurable characteristics of an OO design:

Size. Size is deﬁned in terms of four views: population, volume, length, and
functionality. Population is measured by taking a static count of OO entities
such as classes or operations. Volume measures are identical to population
measures but are collected dynamically—at a given instant of time. Length is
a measure of a chain of interconnected design elements (e.g., the depth of an
inheritance tree is a measure of length). Functionality metrics provide an indi-
rect indication of the value delivered to the customer by an OO application. 

?

What
characteristics

can be measured
when we assess
an OO design?

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

657

Complexity. Like size, there are many differing views of software complex-
ity [ZUS97]. Whitmire views complexity in terms of structural characteristics
by examining how classes of an OO design are interrelated to one another.
Coupling. The physical connections between elements of the OO design
(e.g., the number of collaborations between classes or the number of mes-
sages passed between objects) represent coupling within an OO system.
Sufficiency. Whitmire defines sufficiency as “the degree to which an
abstraction possesses the features required of it, or the degree to which a
design component possesses features in its abstraction, from the point of
view of the current application.” Stated another way, we ask: “What prop-
erties does this abstraction (class) need to possess to be useful to me?”
[WHI97]. In essence, a design component (e.g., a class) is sufficient if it
fully reflects all properties of the application domain object that it is mod-
eling—that is, that the abstraction (class) possesses the features required
of it.
Completeness. The only difference between completeness and sufﬁciency
is “the feature set against which we compare the abstraction or design com-
ponent [WHI97].” Sufﬁciency compares the abstraction from the point of view
of the current application. Completeness considers multiple points of view,
asking the question: “What properties are required to fully represent the
problem domain object?” Because the criterion for completeness considers
different points of view, it has an indirect implication about the degree to
which the abstraction or design component can be reused.
Cohesion. Like its counterpart in conventional software, an OO component
should be designed in a manner that has all operations working together to
achieve a single, well-deﬁned purpose. The cohesiveness of a class is deter-
mined by examining the degree to which “the set of properties it possesses is
part of the problem or design domain” [WHI97].
Primitiveness. A characteristic that is similar to simplicity, primitiveness
(applied to both operations and classes) is the degree to which an operation
is atomic—that is, the operation cannot be constructed out of a sequence of
other operations contained within a class. A class that exhibits a high degree
of primitiveness encapsulates only primitive operations.
Similarity. The degree to which two or more classes are similar in terms of
their structure, function, behavior, or purpose is indicated by this measure.
Volatility. As we have seen earlier in this book, design changes can occur
when requirements are modiﬁed or when modiﬁcations occur in other parts
of an application, resulting in mandatory adaptation of the design component
in question. Volatility of an OO design component measures the likelihood
that a change will occur.

“Many of the design
decisions for which I
had to rely on
folklore and myth
can now be made
using quantitative
data.”
Scott Whitmire 

WebRef
A NASA technical report
addressing quality metrics
for OO systems can be
downloaded from 
satc.gsfc.nasa.gov/
support/index.html

658

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

Whitmire’s derivation of metrics for these design characteristics is beyond the

scope of this book. Interested readers should see [WHI97] for more detail.

In reality, technical metrics for OO systems can be applied not only to the design
model, but also the analysis model. In the sections that follow, we explore metrics
that provide an indication of quality at the OO class level and the operation level. In
addition, metrics applicable for project management and testing are also explored.

24.4 CLASS-ORIENTED METRICS

The class is the fundamental unit of an OO system. Therefore, measures and metrics
for an individual class, the class hierarchy, and class collaborations will be invalu-
able to a software engineer who must assess design quality. In earlier chapters, we
saw that the class encapsulates operations (processing) and attributes (data). The
class is often the “parent” for subclasses (sometimes called children) that inherit its
attributes and operations. The class often collaborates with other classes. Each of
these characteristics can be used as the basis for measurement.2

24.4.1 The CK Metrics Suite
One of the most widely referenced sets of OO software metrics has been proposed
by Chidamber and Kemerer [CHI94]. Often referred to as the CK metrics suite, the
authors have proposed six class-based design metrics for OO systems.3

Weighted methods per class (WMC). Assume that n methods of complexity c1,
c2, . . ., cn are deﬁned for a class C. The speciﬁc complexity metric that is chosen (e.g.,
cyclomatic complexity) should be normalized so that nominal complexity for a method
takes on a value of 1.0.

WMC = ⌺ ci

for i = 1 to n. The number of methods and their complexity are reasonable indica-
tors of the amount of effort required to implement and test a class. In addition, the
larger the number of methods, the more complex is the inheritance tree (all sub-
classes inherit the methods of their parents). Finally, as the number of methods grows
for a given class,  it is likely to become more and more application speciﬁc, thereby
limiting potential reuse. For all of these reasons, WMC should be kept as low as is
reasonable.

The number of
methods and their
complexity are directly
correlated to the effort
required to test a class.

2 It should be noted that the validity of some of the metrics discussed in this chapter is currently

debated in the technical literature. Those who champion measurement theory demand a degree
of formalism that some of the OO metrics do not provide. However, it is reasonable to state that
all of the metrics noted provide useful insight for the software engineer.

3 Chidamber, Darcy,  and Kemerer use the term methods rather than operations. Their usage of the

term is reﬂected in this section.

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

659

Although it would seem relatively straightforward to develop a count for the num-
ber of methods in a class, the problem is actually more complex than it seems.
Churcher and Shepperd [CHU95] discuss this issue when they write:

In order to count methods, we must answer the fundamental question ”Does a method
belong only to the class which defines it, or does it also belong to every class which
inherits it directly or indirectly?” Questions such as this may seem trivial since the run-
time system will ultimately resolve them. However, the implications for metrics may be
significant.

One possibility is to restrict counting to the current class, ignoring inherited members.
The motivation for this would be that inherited members have already been counted in the
classes where they are deﬁned, so the class increment is the best measure of its function-
ality—what it does reﬂects its reason for existing.  In order to understand what a class does,
the most important source of information is its own operations. If a class cannot respond
to a message (i.e., it lacks a corresponding method of its own) then it will pass the mes-
sage on to its parent(s).

At the other extreme, counting could include all methods deﬁned in the current class,
together with all inherited methods. This approach emphasizes the importance of the state
space, rather than the class increment, in understanding a class.

Between these extremes lie a number of other possibilities. For example, one could
restrict counting to the current class and members inherited directly from parent(s). This
approach would be based on the argument that the specialization of parent classes is the
most directly relevant to the behavior of a child class.

Like most counting conventions in software metrics, any of the approaches just out-
lined is acceptable, as long as the counting approach is applied consistently when-
ever metrics are collected.
Depth of the inheritance tree (DIT). This metric is “the maximum length from
the node to the root of the tree” [CHI94]. Referring to Figure 24.1, the value of DIT for
the class-hierarchy shown is 4. As DIT grows, it is likely that lower-level classes will
inherit many methods. This leads to potential difﬁculties when attempting to predict
the behavior of a class. A deep class hierarchy (DIT is large) also leads to greater
design complexity. On the positive side, large DIT values imply that many methods
may be reused.
Number of children (NOC). The subclasses that are immediately subordinate
to a class in the class hierarchy are termed its children. Referring to Figure 24.1,
class C2 has three children—subclasses C21, C22, and C23. As the number of chil-
dren grows, reuse increases but also, as NOC increases, the abstraction repre-
sented by the parent class can be diluted. That is, some of the children may not
really be appropriate members of the parent class. As NOC increases, the amount
of testing (required to exercise each child in its operational context) will also
increase.

Inheritance is an
extremely powerful
feature that can get
you into trouble, if you
use it without care.
Use DIT and other
related metrics to give
yourself a reading on
the complexity of class
hierarchies.

660

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

FIGURE 24.1
A class 
hierarchy

C

C1

C11

C2

C21

C22

C23

C211

Coupling between object classes (CBO). The CRC model (Chapter 21) may be
used to determine the value for CBO. In essence, CBO is the number of collabora-
tions listed for a class on its CRC index card. As CBO increases, it is likely that the
reusability of a class will decrease. High values of CBO also complicate modiﬁcations
and the testing that ensues when modiﬁcations are made. In general, the CBO val-
ues for each class should be kept as low as is reasonable. This is consistent with the
general guideline to reduce coupling in conventional software.
Response for a class (RFC).  The response set of a class is “a set of methods that
can potentially be executed in response to a message received by an object of that
class” [CHI94]. RFC is the number of methods in the response set. As RFC increases,
the effort required for testing also increases because the test sequence (Chapter 23)
grows. It also follows that, as RFC increases, the overall design complexity of the class
increases.
Lack of cohesion in methods (LCOM). Each method within a class, C, accesses
one or more attributes (also called instance variables). LCOM is the number of meth-
ods that access one or more of the same attributes.4 If no methods access the same

4 The formal deﬁnition is a bit more complex. See [CHI94] for details.

The concepts of
coupling and cohesion
apply to both
conventional and OO
software. Keep class
coupling low and class
and operation
cohesion high.

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

661

attributes, then LCOM = 0. To illustrate the case where LCOM ≠ 0, consider a class
with six methods. Four of the methods have one or more attributes in common (i.e.,
they access common attributes). Therefore, LCOM = 4. If LCOM is high, methods may
be coupled to one another via attributes. This increases the complexity of the class
design. In general, high values for LCOM imply that the class might be better designed
by breaking it into two or more separate classes. Although there are cases in which
a high value for LCOM is justiﬁable, it is desirable to keep cohesion high; that is, keep
LCOM low.

24.4.2 Metrics Proposed by Lorenz and Kidd
In their book on OO metrics, Lorenz and Kidd [LOR94] divide class-based metrics
into four broad categories: size, inheritance, internals, and externals. Size-oriented
metrics for the OO class focus on counts of attributes and operations for an individ-
ual class and average values for the OO system as a whole. Inheritance-based met-
rics focus on the manner in which operations are reused through the class hierarchy.
Metrics for class internals look at cohesion (Section 24.4.1) and code-oriented issues,
and external metrics examine coupling and reuse. A sampling of metrics proposed
by Lorenz and Kidd follows:5
Class size (CS). The overall size of a class can be measured by determining the fol-
lowing measures:

• The total number of operations (both inherited and private instance opera-

tions) that are encapsulated within the class.

• The number of attributes (both inherited and private instance attributes) that

are encapsulated by the class.

The WMC metric proposed by Chidamber and Kemerer (Section 24.4.1) is also a
weighted measure of class size. As we noted earlier, large values for CS indicate that
a class may have too much responsibility. This will reduce the reusability of the class
and complicate implementation and testing. In general, inherited or public opera-
tions and attributes should be weighted more heavily in determining class size [LOR94].
Private operations and attributes enable specialization and are more localized in the
design. Averages for the number of class attributes and operations may also be com-
puted. The lower the average values for size, the more likely that classes within the
system can be reused widely.
Number of operations overridden by a subclass (NOO). There are instances when
a subclass replaces an operation inherited from its superclass with a specialized version

“Object-oriented
measures are an
integral part of
object technology
and of good
software
engineering.”
Brian Henderson-
Sellers 

During review of the
OOA model, the CRC
index cards will
provide a reasonable
indication of expected
values for CS. If you
encounter a class with
a large responsibility
count during OOA,
consider partitioning it.

5 For a complete discussion, see [LOR94].

662

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

for its own use. This is called overriding. Large values for NOO generally indicate a design
problem. As Lorenz and Kidd point out: 

Since a subclass should be a specialization of its superclasses, it should primarily extend
the services [operations] of the superclasses. This should result in unique new method
names.

If NOO is large, the designer has violated the abstraction implied by the superclass.
This results in a weak class hierarchy and OO software that can be difﬁcult to test
and modify.

Number of operations added by a subclass (NOA). Subclasses are specialized
by adding private operations and attributes. As the value for NOA increases, the sub-
class drifts away from the abstraction implied by the superclass. In general, as the
depth of the class hierarchy increases (DIT becomes large), the value for NOA at lower
levels in the hierarchy should go down.

Specialization index (SI). The specialization index provides a rough indication of
the degree of specialization for each of the subclasses in an OO system. Specializa-
tion can be achieved by adding or deleting operations or by overriding. 

SI = [NOO ⫻ level]/Mtotal

where level is the level in the class hierarchy at which the class resides and Mtotal is
the total number of methods for the class. The higher is the value of SI, the more likely
the class hierarchy has classes that do not conform to the superclass abstraction.

24.4.3 The MOOD Metrics Suite
Harrison, Counsell, and Nithi [HAR98] propose a set of metrics for object-oriented
design that provide quantitative indicators for OO design characteristics. A sampling
of MOOD metrics follows:

Method inheritance factor (MIF). The degree to which the class architecture of
an OO system makes use of inheritance for both methods (operations) and attributes
is deﬁned as

MIF = ⌺ Mi(Ci)/⌺ Ma(Ci)

where the summation occurs over i = 1 to TC. TC is deﬁned as the total number of
classes in the architecture, Ci is a class within the architecture, and 

Ma(Ci) = Md(Ci) + Mi(Ci) 

where

“Analyzing OO
software in order to
evaluate its quality
is becoming
increasingly
important as the
paradigm continues
to increase in
popularity.”
Rachel Harrison,
et al. 

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

663

Ma(Ci) = the number of methods that can be invoked in association with Ci.
Md(Ci) ) = the number of methods declared in the class Ci.
Mi(Ci) = the number of methods inherited (and not overridden) in Ci.
The value of MIF (the attribute inheritance factor, AIF, is deﬁned in an analogous man-
ner) provides an indication of the impact of inheritance on the OO software.
Coupling factor (CF). Earlier in this chapter we noted that coupling is an indica-
tion of the connections between elements of the OO design. The MOOD metrics suite
deﬁnes coupling in the following way:

CF =  ∑i ∑j is_client (Ci, Cj)]/(TC2 ⫺ TC)

where the summations occur over i = 1 to TC and j = 1 to TC. The function

is_client = 1, if and only if a relationship exists between the client class, Cc, and

the server class, Cs, and Cc ≠ Cs

= 0, otherwise

Although many factors affect software complexity, understandability, and maintain-
ability, it is reasonable to conclude that, as the value for CF increases, the complex-
ity of the OO software will also increase and understandability, maintainability, and
the potential for reuse may suffer as a result.
Polymorphism factor (PF). Harrison and her colleagues [HAR98] deﬁne PF as “the
number of methods that redeﬁne inherited methods, divided by the maximum num-
ber of possible distinct polymorphic situations . . . [t]hus, PF is an indirect measure
of the relative amount of dynamic binding in a system.” The MOOD metrics suite
deﬁnes PF in the following manner:

MIF =  ⌺i Mo(Ci)/⌺i [Mn(Ci) ⫻ DC(Ci)]

where the summations occur over i = 1 to TC and

Md(Ci) = Mn(Ci) + Mo(Ci)

Also,

Mn(Ci) = the number of new methods.
Mo(Ci) = the number of overriding methods.
DC(Ci) = the descendants count (the number of descendant classes of a base class).

Harrison and her colleagues [HAR98] present a detailed analysis of MIF, CF, and PF
along with other metrics and examine their validity for use in the assessment of design
quality.

664

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

24.5 OPERATION-ORIENTED METRICS

XRef
Metrics that can be
applied at the
component level can
also be applied to
operations. See
Chapter 19 for details.

Because the class is the dominant unit in OO systems, fewer metrics have been pro-
posed for operations that reside within a class. Churcher and Shepperd [CHU95] dis-
cuss this when they state:

Results of recent studies indicate that methods tend to be small, both in terms of number
of statements and in logical complexity [WIL93], suggesting that connectivity structure of
a system may be more important than the content of individual modules.

However, some insights can be gained by examining average characteristics for meth-
ods (operations). Three simple metrics, proposed by Lorenz and Kidd [LOR94], are
noted next:
Average operation size (OSavg). Although lines of code could be used as an indi-
cator  for operation size, the LOC measure suffers from all the problems discussed in
Chapter 4. For this reason, the number of messages sent by the operation provides
an alternative for operation size. As the number of messages sent by a single oper-
ation increases, it is likely that responsibilities have not been well-allocated within
a class.
Operation complexity (OC). The complexity of an operation can be computed
using any of the complexity metrics (Chapter 19) proposed for conventional software
[ZUS90]. Because operations should be limited to a speciﬁc responsibility, the designer
should strive to keep OC as low as possible.
Average number of parameters per operation (NPavg). The larger the number
of operation parameters, the more complex the collaboration between objects. In
general, NPavg should be kept as low as possible. 

24.6 METRICS FOR OBJECT-ORIENTED TESTING

The design metrics noted in Sections 24.4 and 24.5 provide an indication of design
quality. They also provide a general indication of the amount of testing effort required
to exercise an OO system.

Binder [BIN94] suggests a broad array of design metrics that have a direct inﬂu-
ence on the “testability” of an OO system. The metrics are organized into categories
that reﬂect important design characteristics.

Encapsulation

Lack of cohesion in methods (LCOM).6 The higher the value of LCOM, the more
states must be tested to ensure that methods do not generate side effects.

6 See Section 24.4.1 for a description of LCOM.

OO testing can be
quite complex. Metrics
can assist you in
targeting testing
resources at threads,
scenarios, and class
clusters that
are”suspect” based on
measured
characteristics. Use
them.

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

665

Percent public and protected (PAP). Public attributes are inherited from other
classes and therefore visible to those classes. Protected attributes are a special-
ization and private to a specific subclass. This metric indicates the percentage of
class attributes that are public. High values for PAP increase the likelihood of side
effects among classes. Tests must be designed to ensure that such side effects are
uncovered.

Public access to data members (PAD). This metric indicates the number of classes
(or methods) that can access another class’s attributes, a violation of encapsulation.
High values for PAD lead to the potential for side effects among classes. Tests must
be designed to ensure that such side effects are uncovered.

Inheritance

Number of root classes (NOR). This metric is a count of the distinct class hierar-
chies that are described in the design model. Test suites for each root class and the
corresponding class hierarchy must be developed. As NOR increases, testing effort
also increases.
Fan-in (FIN). When used in the OO context, fan-in is an indication of multiple inher-
itance. FIN > 1 indicates that a class inherits its attributes and operations from more
than one root class. FIN > 1 should be avoided when possible.
Number of children (NOC) and depth of the inheritance tree (DIT).7 As we
discussed in Chapter 23, superclass methods will have to be retested for each sub-
class.

In addition to these metrics, Binder [BIN94] deﬁnes metrics for class complexity
and polymorphism. The metrics deﬁned for class complexity include three CK met-
rics (Section 24.4.1): weighted methods per class, coupling between object classes,
and response for a class. In addition, metrics associated with method counts are
deﬁned. The metrics associated with polymorphism are highly specialized. A discus-
sion of them is best left to Binder.

24.7 METRICS FOR OBJECT-ORIENTED PROJECTS

As we discovered in Part Two of this book, the job of the project manager is to plan,
coordinate, track, and control a software project. In Chapter 20, we discussed some
of the special issues associated with management of OO projects. But what about
measurement? Are there specialized OO metrics that can be used by the project man-
ager to provide additional insight into progress?8 The answer, of course, is, “Yes.”

7 See Section 24.4.1 for a description of NOC and DIT.
8 A worthwhile discussion of the CK metrics suite (Section 24.4.1) for use in management decision-

making can be found in [CHI98].

666

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

XRef
The applicability of an
evolutionary process
model, called the
recursive/parallel
model, is discussed in
Chapter 20.

The first activity performed by the project manager is planning, and one of the
early planning tasks is estimation. Recalling the evolutionary process model, plan-
ning is revisited after each iteration of the software. Therefore, the plan (and its pro-
ject estimates) are revisited after each iteration of OOA, OOD, and even OOP.

A key issue that faces a project manager during planning is an estimate of the
implemented size of the software. Size is directly proportional to effort and duration.
The following OO metrics [LOR94] can provide insight into software size:
Number of scenario scripts (NSS). The number of scenario scripts or use-cases
(Chapters 11 and 21) is directly proportional to the number of classes required to meet
requirements; the number of states for each class; and the number of methods, attrib-
utes, and collaborations. NSS is a strong indicator of program size.
Number of key classes (NKC). A key class focuses directly on the business domain
for the problem and will have a lower probability of being implemented via reuse.9
For this reason, high values for NKC indicate substantial development work. Lorenz
and Kidd [LOR94} suggest that between 20 and 40 percent of all classes in a typical
OO system are key classes. The remainder support infrastructure (GUI, communica-
tions, databases, etc.).
Number of subsystems (NSUB). The number of subsystems provides insight into
resource allocation, scheduling (with particular emphasis on parallel development)
and overall integration effort.

The metrics NSS, NKC, and NSUB can be collected for past OO projects and are
related to the effort expended on the project as a whole and on individual process
activities (e.g., OOA, OOD, OOP, and OOT). These data can also be used along with
the design metrics discussed earlier in this chapter to compute “productivity metrics”
such as average number of classes per developer or average methods per person-
month. Collectively, these metrics can be used to estimate effort, duration, stafﬁng,
and other information for the current project.

24.8 SUMMARY 

Object-oriented software is fundamentally different than software developed using
conventional methods. Therefore, the metrics for OO systems focus on measurement
that can be applied to the class and the design characteristics—localization, encap-
sulation, information hiding, inheritance, and object abstraction techniques—that
make the class unique.

The CK metrics suite deﬁnes six class-oriented software metrics that focus on the
class and the class hierarchy. The metrics suite also develops metrics to assess the

9 This will be true only until a robust library of reusable components is developed for a particular

domain.

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

667

collaborations between classes and the cohesion of methods that reside within a
class. At a class-oriented level, the CK metrics suite can be augmented with metrics
proposed by Lorenz and Kidd and the MOOD metrics suite. These include measures
of class “size” and metrics that provide insight into the degree of specialization for
subclasses.

Operation-oriented metrics focus on the size and complexity of individual opera-
tions. It is important to note, however, the the primary thrust for OO design metrics
is at the class level.

A wide variety of OO metrics have been proposed to assess the testability of an
OO system. These metrics focus on encapsulation, inheritance, class complexity,
and polymorphism. Many of these metrics have been adapted from the CK metrics
suite and metrics proposed by Lorenz and Kidd. Others have been proposed by
Binder.

Measurable characteristics of the analysis and design model can assist the project
manager for an OO system in planning and tracking activities. The number of sce-
nario scripts (use-cases), key classes, and subsystems provide information about the
level of effort required to implement the system.

REFERENCES

[BER95] Berard, E., Metrics for Object-Oriented Software Engineering, an Internet post-
ing on comp.software-eng, January 28, 1995.
[BIN94] Binder, R.V., “Object-Oriented Software Testing,” CACM, vol. 37, no,. 9, Sep-
tember 1994, p. 29.
[CHI94] Chidamber, S.R. and C.F. Kemerer, “A Metrics Suite for Object-Oriented
Design,” IEEE Trans. Software Engineering, vol. SE-20, no. 6, June 1994, pp. 476–493.
[CHI98] Chidamber, S.R., D.P. Darcy, and C.F. Kemerer, “Management Use of Met-
rics for Object-Oriented Software: An Exploratory Analysis,” IEEE Trans. Software Engi-
neering, vol. SE-24, no. 8, August 1998, pp. 629–639.
[CHU95] Churcher, N.I. and M.J. Shepperd, “Towards a Conceptual Framework for
Object-Oriented Metrics,” ACM Software Engineering Notes, vol. 20, no. 2, April 1995,
pp. 69–76.
[HAR98] Harrison, R., S.J. Counsell, and R.V. Nithi, “An Evaluation of the MOOD Set
of Object-Oriented Software Metrics,” IEEE Trans. Software Engineering, vol. SE-24,
no. 6, June 1998, pp. 491–496. 
[LOR94] Lorenz, M. and J. Kidd, Object-Oriented Software Metrics, Prentice-Hall, 1994.
[WHI97] Whitmire, S., Object-Oriented Design Measurement, Wiley, 1997.
[WIL93] Wilde, N. and R. Huitt, "Maintaining Object-Oriented Software," IEEE Soft-
ware, January 1993, pp. 75–80.
[ZUS90] Zuse, H., Software Complexity: Measures and Methods, DeGruyter, 1990.
[ZUS97] Zuse, H., A Framework of Software Measurement, DeGruyter, 1997.

668

PART FOUR OBJECT-ORIENTED SOFTWARE ENGINEERING

PROBLEMS AND POINTS TO PONDER

24.1. Review the metrics presented in this chapter and in Chapter 19. How would
you characterize the syntactic and semantic differences between metrics for con-
ventional and OO software?

24.2. How does localization affect metrics developed for conventional and OO soft-
ware?

24.3. Why isn’t more emphasis given to OO metrics that address the speciﬁc char-
acteristics of operations within a class?

24.4. Review the metrics discussed in this chapter and suggest a few that directly
or indirectly address the information hiding design characteristic.

24.5. Review the metrics discussed in this chapter and suggest a few that directly
or indirectly address the abstraction design characteristic.

24.6. A class, X, has 12 operations. Cyclomatic complexity has been computed for
all operations in the OO system and the average value of module complexity is 4. For
class X, the complexity for operations 1 to 12 is 5, 4, 3, 3, 6, 8, 2, 2, 5, 5, 4, 4, respec-
tively. Compute the weighted methods per class.

24.7. Referring to Figure 20.8, compute the value of DIT for each inheritance tree.
What is the value of NOC for the class X2 for both trees?

24.8. Refer to [CHI94] and present a one-page discussion of the formal deﬁnition of
the LCOM metric.

24.9. Referring to Figure 20.8B, what is the value of NOA for classes X3 and X4?

24.10. Referring to Figure 20.8B, assume that four operations have been overrid-
den in the inheritance tree (class hierarchy), what is the value of SI for the hierarchy?

24.11. A software team has completed ﬁve OO projects to date. The following data
have been collected for all size projects:

Project

1
2
3
4
5

NSS
34
55
122
45
80

NKC
60
75
260
66
124

NSUB

Effort (days)

3
6
8
2
6

900
1575
4420
990
2480

A new project is in early stages of OOA. It is estimated that 95 use-cases will be devel-
oped for the project. Estimate 

a. The total number of classes that will be required to implement the system.
b. The total amount of effort required to implement the system.

CHAPTER 24

TECHNICAL METRICS FOR OBJECT-ORIENTED SYSTEMS

669

24.12. Your instructor will provide you with a list of OO metrics from this chapter.
Compute the values of these metrics for one or more of these problems:

a. The design model for the SafeHome design.
b. The design model for the PHTRS system described in Problem 12.13. 
c. The design model for the video game considered in Problem 22.14.
d. The design model for the e-mail considered in Problem 22.15.
e. The design model for the ATC system considered in Problem 22.16.

FURTHER READINGS AND INFORMATION SOURCES

A variety of books on OOA, OOD, and OOT (see Further Readings and Information
Sources in Chapters 20, 21, and 22) make passing reference to OO metrics, but few
address the subject in any detail. Books by Jacobson (Object-Oriented Software Engi-
neering, Addison-Wesley, 1994) and Graham (Object-Oriented Methods, Addison-
Wesley, 2nd ed., 1993) provide more treatment than most. 

Whitmire [WHI97] presents the most comprehensive and mathematically sophis-
ticated treatment of OO metrics published to date. Lorenz and Kidd [LOR94] and
Hendersen-Sellers (Object-Oriented Metrics: Measures of Complexity, Prentice-Hall,
1996) offer the only other books dedicated to OO metrics. Other books dedicated to
conventional software metrics (see Further Readings and Information Sources for
Chapters 4 and 19) contain limited discussions of OO metrics.

A wide variety of information sources on object-oriented metrics and related sub-
jects is available on the Internet. An up-to-date list of World Wide Web references
that are relevant to OO metrics can be found at the SEPA Web site:
http://www.mhhe.com/engcs/compsci/pressman/resources/OOM.mhtml

P A R T

Five

ADVANCED TOPICS
IN SOFTWARE
ENGINEERING

In this part of Software Engineering: A Practitioner’s Approach, we

consider a number of advanced topics that will extend your
understanding of software engineering. In the chapters that fol-

low, we address the following questions:

• What notation and mathematical preliminaries (“formal

methods”) are required to formally specify software?

• What key technical activities are conducted during the

cleanroom software engineering process?

• How is component-based software engineering used to cre-

ate systems from reusable components?

• How does the client/server architecture affect the way in

which software is engineered?

• Are software engineering concepts and principles applicable

for Web-based applications and products?

• What key technical activities are required for software

reengineering?

• What are the architectural options for establishing a CASE

tools environment?

• What are the future directions of software engineering?

Once these questions are answered, you’ll understand topics that
may have a profound impact on software engineering over the next
decade.

671

